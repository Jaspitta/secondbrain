

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>16.2. Algorithms on trees</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="16.3. Traversals" href="16_3_traversals.html" />
    <link rel="prev" title="16.1. Binary tree" href="16_1_binary.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="16-introduction.html">16. Rooted trees</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="16_1_binary.html">16.1. Binary tree</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">16.2. Algorithms on trees</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Divide-and-conquer">16.2.1. Divide and conquer</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-16.2.1">Exercise 16.2.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-16.2.2">Exercise 16.2.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Arm's-length-recursion">16.2.2. Arm’s-length recursion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="16_3_traversals.html">16.3. Traversals</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_4_bst.html">16.4. Binary search trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_5_balanced.html">16.5. Balanced trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_6_heapsort.html">16.6. Heapsort</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_7_summary.html">16.7. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="16-introduction.html"><span class="section-number">16. </span>Rooted trees</a></li>
      <li class="breadcrumb-item active"><span class="section-number">16.2. </span>Algorithms on trees</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Algorithms-on-trees">
<h1><span class="section-number">16.2. </span>Algorithms on trees<a class="headerlink" href="#Algorithms-on-trees" title="Link to this heading"></a></h1>
<p>Algorithms on binary trees usually follow a <a class="reference internal" href="../13_Divide/13_7_summary.html"><span class="doc">divide-and-conquer approach</span></a> to process both subtrees and thereby all nodes. This takes linear time in the size of the tree, assuming that processing each node takes constant time. Let’s see a concrete example: computing the size of a tree.</p>
<section id="Divide-and-conquer">
<h2><span class="section-number">16.2.1. </span>Divide and conquer<a class="headerlink" href="#Divide-and-conquer" title="Link to this heading"></a></h2>
<p>Due to the recursive definition of binary trees, a function f on them is usually defined recursively like this:</p>
<ol class="arabic simple">
<li><p>if <em>tree</em> is empty: f(<em>tree</em>) = …</p></li>
<li><p>otherwise: f(<em>tree</em>) = an expression based on operations root, left, right and join.</p></li>
</ol>
<p>To come up with such a definition you need to answer these questions:</p>
<ol class="arabic simple">
<li><p>What’s the output for an empty tree?</p></li>
<li><p>If I know the outputs for the left and right subtrees, what’s the output for the whole tree?</p></li>
</ol>
<p>For example, the size of the empty tree is zero, and if I know the sizes of the left and right subtrees, then the size of the tree is their sum plus one, for the root.</p>
<ul class="simple">
<li><p>if <em>tree</em> is empty: size(<em>tree</em>) = 0</p></li>
<li><p>otherwise: size(<em>tree</em>) = size(left(<em>tree</em>)) + size(right(<em>tree</em>)) + 1</p></li>
</ul>
<p>The recursive definition of the length of a sequence didn’t refer to the head of the sequence; similarly, the size of a tree doesn’t refer to the root.</p>
<p>Like for sequences, recursive definitions on trees are straightforward to translate to code. First we must ‘import’ the definition of <code class="docutils literal notranslate"><span class="pre">Tree</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_tree
</pre></div>
</div>
</div>
<p>Now we can define a new operation on binary trees.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this code is also in m269_tree.py</span>


<span class="k">def</span><span class="w"> </span><span class="nf">size</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the number of nodes in tree.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">size</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<p>I test the function on one expression tree, as they all have the same size.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">size</span><span class="p">(</span><span class="n">TPM</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
7
</pre></div></div>
</div>
<section id="Exercise-16.2.1">
<h3>Exercise 16.2.1<a class="headerlink" href="#Exercise-16.2.1" title="Link to this heading"></a></h3>
<p>Recursively define the height of a tree.</p>
<ul class="simple">
<li><p>if <em>tree</em> is empty: height(<em>tree</em>) = …</p></li>
<li><p>otherwise: height(<em>tree</em>) =</p></li>
</ul>
<p><a class="reference internal" href="../31_Hints/Hints_16_2_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_16_2_01.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-16.2.2">
<h3>Exercise 16.2.2<a class="headerlink" href="#Exercise-16.2.2" title="Link to this heading"></a></h3>
<p>Implement the operation.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_tree
<span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">test</span>


<span class="k">def</span><span class="w"> </span><span class="nf">height</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the height of the tree.&quot;&quot;&quot;</span>
    <span class="k">pass</span>


<span class="n">height_tests</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># case,         tree,   height</span>
    <span class="p">(</span><span class="s1">&#39;empty tree&#39;</span><span class="p">,</span>  <span class="n">Tree</span><span class="p">(),</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;(3+4)*(5-6)&#39;</span><span class="p">,</span> <span class="n">TPM</span><span class="p">,</span>    <span class="mi">3</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;3+((4*5)-6)&#39;</span><span class="p">,</span> <span class="n">PMT</span><span class="p">,</span>    <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;(3+(4*5))-6&#39;</span><span class="p">,</span> <span class="n">MPT</span><span class="p">,</span>    <span class="mi">4</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">test</span><span class="p">(</span><span class="n">height</span><span class="p">,</span> <span class="n">height_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../32_Answers/Answers_16_2_02.html"><span class="doc">Answer</span></a></p>
</section>
</section>
<section id="Arm's-length-recursion">
<h2><span class="section-number">16.2.2. </span>Arm’s-length recursion<a class="headerlink" href="#Arm's-length-recursion" title="Link to this heading"></a></h2>
<p>The size algorithm always does two recursive calls per node, whether a node has 0, 1 or 2 children. However, empty subtrees don’t add anything to the size of the tree. Making a recursive call to immediately return zero seems a bit pointless.</p>
<p><strong>Arm’s-length recursion</strong> checks for the base case <em>before</em> making a recursive call. For the size function, this means checking if a subtree is empty and not making a recursive call if it is. Since one or both subtrees may be empty, we must check three additional cases. The base case must still be checked in case the whole tree is empty.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">size_arm</span><span class="p">(</span><span class="n">tree</span><span class="p">:</span> <span class="n">Tree</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the size of the tree using arm&#39;s length recursion.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">elif</span> <span class="n">is_leaf</span><span class="p">(</span><span class="n">tree</span><span class="p">):</span>  <span class="c1"># both subtrees empty</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">):</span>  <span class="c1"># left subtree empty</span>
        <span class="k">return</span> <span class="n">size_arm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">):</span>  <span class="c1"># right subtree empty</span>
        <span class="k">return</span> <span class="n">size_arm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">size_arm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">size_arm</span><span class="p">(</span><span class="n">tree</span><span class="o">.</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
</pre></div>
</div>
</div>
<p>The new algorithm is longer, inelegant, repetitive and thus prone to typos and other errors. It only recurs on non-empty subtrees, so it makes as many recursive calls as there are nodes, not twice as much, but each call makes more checks. Let’s compare this version to the first one, using a tall tree with one child per node; essentially, a linked list.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">tree</span> <span class="o">=</span> <span class="n">leaf</span><span class="p">(</span><span class="s2">&quot;last node&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">level</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1000</span><span class="p">):</span>  <span class="c1"># noqa: B007</span>
    <span class="n">tree</span> <span class="o">=</span> <span class="n">join</span><span class="p">(</span><span class="s2">&quot;a parent node&quot;</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">Tree</span><span class="p">())</span>

<span class="o">%</span><span class="k">timeit</span> -r 5 size(tree)
<span class="o">%</span><span class="k">timeit</span> -r 5 size_arm(tree)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
250 μs ± 664 ns per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
458 μs ± 1.58 μs per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
</pre></div></div>
</div>
<p>In this example, arm’s length recursion takes longer, even though it makes fewer recursive calls.</p>
<div class="admonition warning">
<p><strong>Note:</strong> Avoid arm’s length recursion: it complicates your code and usually slows it down.</p>
</div>
<p>If an operation isn’t defined for the empty tree, then an algorithm must first check if a subtree isn’t empty before making a recursive call. Consider finding the largest item in a binary tree. The preconditions are that the input tree isn’t empty and its items are comparable.</p>
<ul class="simple">
<li><p>if <em>tree</em> is a leaf: largest(<em>tree</em>) = root(<em>tree</em>)</p></li>
<li><p>if left(<em>tree</em>) is empty and right(<em>tree</em>) isn’t: largest(<em>tree</em>) = max(largest(right(<em>tree</em>)), root(<em>tree</em>))</p></li>
<li><p>if right(<em>tree</em>) is empty and left(<em>tree</em>) isn’t: largest(<em>tree</em>) = max(largest(left(<em>tree</em>)), root(<em>tree</em>))</p></li>
<li><p>otherwise: largest(<em>tree</em>) = max(largest(left(<em>tree</em>)), largest(right(<em>tree</em>)), root(<em>tree</em>))</p></li>
</ul>
<p>This is <em>not</em> arm’s-length recursion: each recurrence relation is checking for the empty tree, not for the base case (tree is a leaf). The definition is making sure no recursive call violates the preconditions.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="16_1_binary.html" class="btn btn-neutral float-left" title="16.1. Binary tree" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="16_3_traversals.html" class="btn btn-neutral float-right" title="16.3. Traversals" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>