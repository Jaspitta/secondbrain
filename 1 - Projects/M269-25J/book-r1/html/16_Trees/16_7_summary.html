

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>16.7. Summary</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="17. Graphs 1" href="../17_Graphs_1/17-introduction.html" />
    <link rel="prev" title="16.6. Heapsort" href="16_6_heapsort.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="16-introduction.html">16. Rooted trees</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="16_1_binary.html">16.1. Binary tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_2_algorithms.html">16.2. Algorithms on trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_3_traversals.html">16.3. Traversals</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_4_bst.html">16.4. Binary search trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_5_balanced.html">16.5. Balanced trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="16_6_heapsort.html">16.6. Heapsort</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">16.7. Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Rooted-trees">16.7.1. Rooted trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Binary-trees">16.7.2. Binary trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Binary-search-trees">16.7.3. Binary search trees</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Heaps">16.7.4. Heaps</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="16-introduction.html"><span class="section-number">16. </span>Rooted trees</a></li>
      <li class="breadcrumb-item active"><span class="section-number">16.7. </span>Summary</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Summary">
<h1><span class="section-number">16.7. </span>Summary<a class="headerlink" href="#Summary" title="Link to this heading"></a></h1>
<section id="Rooted-trees">
<h2><span class="section-number">16.7.1. </span>Rooted trees<a class="headerlink" href="#Rooted-trees" title="Link to this heading"></a></h2>
<p>A <strong>rooted tree</strong> consists of zero or more <strong>nodes</strong>. Each node contains an item and is the <strong>parent</strong> of zero or more <strong>child</strong> nodes. The root node has no parent; every other node has exactly one parent. The <strong>leaves</strong> are the nodes without children. The <strong>size</strong> of a tree is how many nodes (or items) it has.</p>
<p>Rooted trees represent hierarchical collections of items, organised by <strong>levels</strong>. The <strong>height</strong> of a tree is how many levels it has. Level zero, the top level, contains only the root. If a node is at level <em>n</em>, then its children are at level, or <strong>depth</strong>, <em>n</em> + 1 and its parent is at level <em>n</em> − 1.</p>
<p>The <strong>ancestors</strong> of a node are its parent, parent’s parent, and so on until the root. The <strong>descendants</strong> of a node are its children, children’s children and so on until reaching leaf nodes.</p>
<p>There are two basic ways of exhaustively searching a rooted tree. A breadth-first search (BFS) generates the nodes level by level: all of a node’s children are tested before testing their children. A depth-first search (DFS) generates and tests all descendants of a node’s child before doing the same for the next child of that node. A <strong>pre- or post-order traversal</strong> is a DFS that tests a node respectively before or after its children.</p>
</section>
<section id="Binary-trees">
<h2><span class="section-number">16.7.2. </span>Binary trees<a class="headerlink" href="#Binary-trees" title="Link to this heading"></a></h2>
<p>In a <strong>binary tree</strong>, each node has at most two children, called the <strong>left child</strong> and <strong>right child</strong>. A binary tree can be recursively defined as being empty or consisting of a root and two binary trees, called the left and right <strong>subtrees</strong>. The binary tree ADT operations are directly based on this definition:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Operation</p></th>
<th class="head"><p>Effect</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>new</p></td>
<td><p>create a new empty binary tree</p></td>
</tr>
<tr class="row-odd"><td><p>join(<em>i</em>, <em>l</em>, <em>r</em>)</p></td>
<td><p>create a tree with root item <em>i</em> and subtrees <em>l</em> and <em>r</em></p></td>
</tr>
<tr class="row-even"><td><p>root(<em>t</em>)</p></td>
<td><p>obtain the root item of binary tree <em>t</em></p></td>
</tr>
<tr class="row-odd"><td><p>left(<em>t</em>)</p></td>
<td><p>obtain the left subtree of <em>t</em></p></td>
</tr>
<tr class="row-even"><td><p>right(<em>t</em>)</p></td>
<td><p>obtain the right subtree of <em>t</em></p></td>
</tr>
<tr class="row-odd"><td><p><em>t</em> is empty</p></td>
<td><p>check if <em>t</em> has no nodes</p></td>
</tr>
</tbody>
</table>
<p>When writing algorithms in English, the new operation is written as: let <em>t</em> be an empty binary tree. Operations root, left and right assume <em>t</em> isn’t empty. All operations can be implemented in constant time.</p>
<p>Due to their recursive structure, binary trees can be processed with recursive divide-and-conquer algorithms. The base case is either an empty tree or a leaf. <strong>Arm’s-length recursion</strong>, which tests the base case before the recursive call, should be avoided as it complicates the algorithm and usually makes it slower.</p>
<p>An <strong>in-order traversal</strong> of a binary tree is a DFS that processes the root in between processing the left and right subtrees.</p>
<p>The <strong>balance factor</strong> of a node is the difference between the left subtree’s height and the right subtree’s height. A binary tree is <strong>balanced</strong> if every node has balance factor −1, 0 or 1.</p>
<p>A binary tree is <strong>complete</strong> if all levels, except possibly the last one, are full and the leaves on the last level have no gaps from left to right. A binary tree is <strong>perfect</strong> if all its levels are full. Complete trees and perfect trees are balanced.</p>
<p>The height of a binary tree is at least log │<em>tree</em>│, for a complete tree, and at most │<em>tree</em>│, for a tree that has one node per level. For a balanced tree, the height is proportional to log │<em>tree</em>│.</p>
</section>
<section id="Binary-search-trees">
<h2><span class="section-number">16.7.3. </span>Binary search trees<a class="headerlink" href="#Binary-search-trees" title="Link to this heading"></a></h2>
<p>A <strong>binary search tree</strong> (<strong>BST</strong>) is a binary tree with an ordering property: each item is larger than the items in the left subtree and smaller than the items in the right subtree. Moreover, each subtree is a BST itself. An in-order traversal of a BST produces items in ascending order.</p>
<p>BSTs are used to implement the map ADT, if items are key–value pairs with unique and comparable keys. All map operations require to first search for the node with the given key. This can be done with a binary search, due to the ordering of the items.</p>
<p>Binary search visits one node per level so it takes linear time in the height of the tree, assuming each visited node takes constant time to process. Binary search is Θ(1) in the best case, Θ(log │<em>tree</em>│) in the average case, and Θ(│<em>tree</em>│) in the worst case.</p>
<p>A <strong>self-balancing BST</strong> automatically balances itself after a node has been inserted or removed.</p>
</section>
<section id="Heaps">
<h2><span class="section-number">16.7.4. </span>Heaps<a class="headerlink" href="#Heaps" title="Link to this heading"></a></h2>
<p>A <strong>min-heap</strong> or <strong>max-heap</strong> is a binary tree with an additional structural property (it’s complete) and an ordering property: each item (or its key) is respectively smaller or larger than its children (or their keys). Min- and max-heaps are used to implement priority queues: the smallest or largest priority item is in the root.</p>
<p>A heap can be efficiently stored and manipulated in an array. A new item is added as the last node and bubbles up the tree while it’s smaller (or larger, for a max-heap) than the parent. When the root is removed, the last item takes its place and bubbles down while it’s larger (respectively, smaller) than their children. Inserting an item and removing the root take logarithmic time at worst, when the item moves up (or the new root moves down) the height of the tree.</p>
<p>In Python, min-heaps can be created by repeatedly calling <code class="docutils literal notranslate"><span class="pre">heappush(heap,</span> <span class="pre">item)</span></code> on an initially empty list <code class="docutils literal notranslate"><span class="pre">heap</span></code>. The items added to the heap must be comparable. Calling <code class="docutils literal notranslate"><span class="pre">heappop(heap)</span></code> on a non-empty heap returns and removes the root item. Both functions are in module <code class="docutils literal notranslate"><span class="pre">heapq</span></code>.</p>
<p><strong>Heapsort</strong> is a form of selection sort with unsorted items kept in a min-heap instead of a sequence. Heapsort has linear best-case complexity and log-linear worst-case complexity. Due to swapping items up and down across the whole array, heapsort doesn’t have good cache locality and is slower in practice than in-place quicksort.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="16_6_heapsort.html" class="btn btn-neutral float-left" title="16.6. Heapsort" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../17_Graphs_1/17-introduction.html" class="btn btn-neutral float-right" title="17. Graphs 1" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>