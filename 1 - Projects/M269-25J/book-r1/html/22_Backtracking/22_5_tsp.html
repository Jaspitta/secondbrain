

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>22.5. Back to the TSP</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="22.6. Generate subsets" href="22_6_subsets.html" />
    <link rel="prev" title="22.4. Optimise" href="22_4_optimising.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="22-introduction.html">22. Backtracking</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="22_1_sequences.html">22.1. Generate sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_2_pruning.html">22.2. Prune the search space</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_3_trackword.html">22.3. Trackword</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_4_optimising.html">22.4. Optimise</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">22.5. Back to the TSP</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#The-main-function">22.5.1. The main function</a></li>
<li class="toctree-l3"><a class="reference internal" href="#The-value-function">22.5.2. The value function</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.5.1">Exercise 22.5.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Checking-the-constraints">22.5.3. Checking the constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.5.2">Exercise 22.5.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.5.3">Exercise 22.5.3</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#The-backtracking-function">22.5.4. The backtracking function</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.5.4">Exercise 22.5.4</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.5.5">Exercise 22.5.5</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="22_6_subsets.html">22.6. Generate subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_7_knapsack.html">22.7. Back to the knapsack</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_8_summary.html">22.8. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="22-introduction.html"><span class="section-number">22. </span>Backtracking</a></li>
      <li class="breadcrumb-item active"><span class="section-number">22.5. </span>Back to the TSP</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Back-to-the-TSP">
<h1><span class="section-number">22.5. </span>Back to the TSP<a class="headerlink" href="#Back-to-the-TSP" title="Link to this heading"></a></h1>
<p>In this section, we solve an optimisation problem with backtracking: the <a class="reference internal" href="../18_Greed/18_2_weighted_graph.html#Weighted-graphs"><span class="std std-ref">travelling salesman problem</span></a> (TSP).</p>
<div class="line-block">
<div class="line"><strong>Function</strong>: tsp</div>
<div class="line"><strong>Inputs</strong>: <em>graph</em>, a weighted undirected graph</div>
<div class="line"><strong>Preconditions</strong>: <em>graph</em> is complete; the nodes are 0, 1, …; the weights are positive</div>
<div class="line"><strong>Output</strong>: <em>shortest</em>, a sequence of nodes of <em>graph</em></div>
<div class="line"><strong>Postconditions</strong>:</div>
</div>
<ul class="simple">
<li><p><em>shortest</em> is a tour that starts and ends at node 0</p></li>
<li><p>no other tour of <em>graph</em> has a lower total weight than <em>shortest</em></p></li>
</ul>
<p>Real networks seldom have connections between all nodes, but we can model any network as a complete graph by adding the missing edges with infinite weight. This prevents them from being selected for a shortest tour.</p>
<p>Here’s a graph to test the algorithm. Edges 0–2 and 1–4 have infinite weight, to show they’re missing in the network being modelled.</p>
<p id="fig-22.5.1"></p><p><a class="reference internal" href="../33_Figures/Figures_22_5.html#Figure-22.5.1"><span class="std std-ref">Figure 22.5.1</span></a></p>
<img alt="Image 22_5_tsp.png" src="../_images/22_5_tsp.png" />
<p>The graph has 4! = 24 tours that start and end at node 0, but only those of finite length exist in the network modelled by the graph: (0, 1, 2, 3, 4, 0), (0, 1, 2, 4, 3, 0), (0, 1, 3, 2, 4, 0), (0, 3, 1, 2, 4, 0) and the reverse sequences. The shortest tours are (0, 3, 1, 2, 4, 0) and (0, 4, 2, 1, 3, 0) with length 50.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">math</span>

<span class="o">%</span><span class="k">run</span> -i ../m269_digraph.py     # (un)weighted directed graph classes
<span class="o">%</span><span class="k">run</span> -i ../m269_ungraph.py     # undirected graph classes inherit from directed

<span class="n">example</span> <span class="o">=</span> <span class="n">WeightedUndirectedGraph</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">example</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
<span class="n">example</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Previously, we started with high-level questions about what the items, the candidates and the solutions are, to have a good understanding of the problem before solving it. Another approach is to let the backtracking code template guide the questions.</p>
<section id="The-main-function">
<h2><span class="section-number">22.5.1. </span>The main function<a class="headerlink" href="#The-main-function" title="Link to this heading"></a></h2>
<p>The TSP is an optimisation problem on tours, which can be represented as sequences of nodes. So let’s start with the main function template for optimisation problems on sequences.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">SOLUTION</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">VALUE</span> <span class="o">=</span> <span class="mi">1</span>

<span class="k">def</span><span class="w"> </span><span class="nf">problem</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the best solution and its value for the problem instance.&quot;&quot;&quot;</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extensions</span> <span class="o">=</span> <span class="o">...</span>
    <span class="n">solution</span> <span class="o">=</span> <span class="o">...</span>
    <span class="n">best</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span><span class="p">,</span> <span class="n">value</span><span class="p">(</span><span class="n">solution</span><span class="p">)]</span>
    <span class="n">extend</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">extensions</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">best</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">best</span>
</pre></div>
</div>
<p>Let’s go through it line by line.</p>
<p>The problem is the TSP and the instance is a weighted undirected graph, so the function header becomes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">tsp</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">WeightedUndirectedGraph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
</pre></div>
</div>
<p>Usually, the initial candidate is the empty sequence and the initial extensions form a set of items to be added to the sequence, each item occurring at most once in a solution. For the TSP problem that’s not true: node 0 occurs at the start and end of each tour. To be able to generate tours, the root candidate must be sequence (0) and the extensions are all the nodes in the graph, so that node 0 can be added a second time to the sequence.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">candidate</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">extensions</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
</pre></div>
</div>
<p>As for initialising the best solution, I could construct the tour (0, 1, 2, …, <em>n</em>–1, 0) and compute its length.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solution</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span> <span class="o">+</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">best</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span><span class="p">,</span> <span class="n">value</span><span class="p">(</span><span class="n">solution</span><span class="p">)]</span>  <span class="c1"># function value to be written</span>
</pre></div>
</div>
<p>However, I take the opportunity to show you a trick that works for any optimisation problem on sequences, especially when there’s no easy way of constructing a good initial solution. We start with a ‘pseudo-solution’ (usually the empty sequence) and an infinitely high or low value, depending on whether it’s a minimisation or maximisation problem. This guarantees that the first solution found is necessarily better.</p>
<p>The TSP is a minimisation problem, so we start with an infinitely high value.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">solution</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">best</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
</pre></div>
</div>
<p>The problem only asks for the tour, not its length, so the last template line becomes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">return</span> <span class="n">best</span><span class="p">[</span><span class="n">SOLUTION</span><span class="p">]</span>
</pre></div>
</div>
<p>Let’s put all this together and make the docstring and variable names less generic.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">SOLUTION</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">VALUE</span> <span class="o">=</span> <span class="mi">1</span>


<span class="k">def</span><span class="w"> </span><span class="nf">tsp</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">WeightedUndirectedGraph</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a tour-length pair with shortest length.</span>

<span class="sd">    Preconditions:</span>
<span class="sd">    graph is complete, has nodes 0, 1, ..., and positive weights</span>
<span class="sd">    Postconditions: tour starts and ends at node 0</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span>
    <span class="n">solution</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">shortest</span> <span class="o">=</span> <span class="p">[</span><span class="n">solution</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">]</span>
    <span class="n">extend</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">graph</span><span class="p">,</span> <span class="n">shortest</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">shortest</span><span class="p">[</span><span class="n">SOLUTION</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>The backtracking algorithm, implemented by function <code class="docutils literal notranslate"><span class="pre">extend</span></code>, is mostly boilerplate. The problem-specific computations are in the auxiliary functions that compute the value of a candidate and check the constraints, so let’s tackle them next.</p>
</section>
<section id="The-value-function">
<h2><span class="section-number">22.5.2. </span>The value function<a class="headerlink" href="#The-value-function" title="Link to this heading"></a></h2>
<p>For any optimisation problem, we must compute the value of a candidate to know whether it improves on the best solution so far. For the TSP, what is a candidate and what does the value function compute?</p>
<hr class="docutils" />
<p>A candidate is a sequence of nodes representing a path starting at node 0. The function computes the total weight of the edges between consecutive nodes. The next exercise asks you to implement the value function. Before that, I recommend you uncomment and run the next code line to remind yourself of the available graph methods and their parameters.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># help(WeightedUndirectedGraph)</span>
</pre></div>
</div>
</div>
<section id="Exercise-22.5.1">
<h3>Exercise 22.5.1<a class="headerlink" href="#Exercise-22.5.1" title="Link to this heading"></a></h3>
<p>For this and the following exercises, you’re given a code template that you must adapt and complete for the TSP. Adapting the code means to:</p>
<ul class="simple">
<li><p>replace the generic docstrings and identifiers with problem-specific ones (you can press F, not Shift-F, in command mode to find and replace text in the current cell or in all cells)</p></li>
<li><p>remove any unnecessary parameters.</p></li>
</ul>
<p>Adapt and complete the following value function template for the TSP.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">value</span><span class="p">(</span><span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the value of the candidate sequence for the problem instance.&quot;&quot;&quot;</span>
    <span class="k">pass</span>  <span class="c1"># replace with your code</span>


<span class="n">value</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">example</span><span class="p">)</span> <span class="o">==</span> <span class="mi">55</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../31_Hints/Hints_22_5_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_22_5_01.html"><span class="doc">Answer</span></a></p>
</section>
</section>
<section id="Checking-the-constraints">
<h2><span class="section-number">22.5.3. </span>Checking the constraints<a class="headerlink" href="#Checking-the-constraints" title="Link to this heading"></a></h2>
<p>Two auxiliary functions check the global and local constraints on candidates. For the TSP, candidates are paths (sequences of nodes) starting at node 0, and solutions are candidates representing tours. The questions to think about are as follows.</p>
<ul class="simple">
<li><p>Can partial candidates be solutions?</p></li>
</ul>
<hr class="docutils" />
<p>A tour has all the graph’s nodes, so solutions must be complete candidates; that is, when there’s no further node to add to the sequence.</p>
<ul class="simple">
<li><p>What are the constraints on a complete candidate for it to be a solution?</p></li>
</ul>
<hr class="docutils" />
<p>The candidate path ends with node 0 and each node has an edge to the next one.</p>
<ul class="simple">
<li><p>Which constraints are local (can be checked on partial candidates) and which are global (must be checked on complete candidates)?</p></li>
</ul>
<hr class="docutils" />
<p>The existence of edges between consecutive nodes is a local constraint. The sequence ending with node 0 is a global constraint.</p>
<section id="Exercise-22.5.2">
<h3>Exercise 22.5.2<a class="headerlink" href="#Exercise-22.5.2" title="Link to this heading"></a></h3>
<p>Adapt and complete the next code template for the TSP.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">satisfies_global</span><span class="p">(</span><span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the candidate satisfies the global constraints.&quot;&quot;&quot;</span>
    <span class="k">pass</span>  <span class="c1"># replace with your code</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../32_Answers/Answers_22_5_02.html"><span class="doc">Answer</span></a></p>
<p><a class="reference internal" href="22_4_optimising.html#Avoid-worse-candidates"><span class="std std-ref">Section 22.4.3</span></a> mentions that if extending a candidate worsens its value, then it shouldn’t be further extended when it reaches the best value so far.</p>
<p>For the TSP, does extending a candidate worsen its value?</p>
<hr class="docutils" />
<p>The value of a candidate path is its length: the total weights of its edges. The problem definition tells us weights are positive, so extending a path increases its length, which for a minimisation problem is a worse value.</p>
</section>
<section id="Exercise-22.5.3">
<h3>Exercise 22.5.3<a class="headerlink" href="#Exercise-22.5.3" title="Link to this heading"></a></h3>
<p>Adapt and complete the next code template for the TSP.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">can_extend</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">best</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if item can extend candidate into a better solution than best.&quot;&quot;&quot;</span>
    <span class="c1"># replace ... with a check for the local constraints</span>
    <span class="c1"># use &lt; for a minimisation problem</span>
    <span class="k">return</span> <span class="o">...</span> <span class="ow">and</span> <span class="n">value</span><span class="p">(</span><span class="n">candidate</span> <span class="o">+</span> <span class="p">[</span><span class="n">item</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">best</span><span class="p">[</span><span class="n">VALUE</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../31_Hints/Hints_22_5_03.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_22_5_03.html"><span class="doc">Answer</span></a></p>
</section>
</section>
<section id="The-backtracking-function">
<h2><span class="section-number">22.5.4. </span>The backtracking function<a class="headerlink" href="#The-backtracking-function" title="Link to this heading"></a></h2>
<p>Now we have all auxiliary functions in place for the backtracking algorithm.</p>
<section id="Exercise-22.5.4">
<h3>Exercise 22.5.4<a class="headerlink" href="#Exercise-22.5.4" title="Link to this heading"></a></h3>
<p>Adapt the next code template to the TSP. Don’t forget to change the calls to <code class="docutils literal notranslate"><span class="pre">satisfies_global</span></code>, <code class="docutils literal notranslate"><span class="pre">value</span></code> and <code class="docutils literal notranslate"><span class="pre">can_extend</span></code> if you changed their names in the cells above.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">extensions</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">best</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Update best if candidate is a better solution, otherwise extend it.&quot;&quot;&quot;</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Visiting node&quot;</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">extensions</span><span class="p">)</span>
    <span class="c1"># remove the next line if partial candidates can be solutions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">satisfies_global</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
            <span class="n">candidate_value</span> <span class="o">=</span> <span class="n">value</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>
            <span class="c1"># in the next line, use &lt; for minimisation problems</span>
            <span class="k">if</span> <span class="n">candidate_value</span> <span class="o">&gt;</span> <span class="n">best</span><span class="p">[</span><span class="n">VALUE</span><span class="p">]:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;New best with value&quot;</span><span class="p">,</span> <span class="n">candidate_value</span><span class="p">)</span>
                <span class="n">best</span><span class="p">[</span><span class="n">SOLUTION</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate</span>
                <span class="n">best</span><span class="p">[</span><span class="n">VALUE</span><span class="p">]</span> <span class="o">=</span> <span class="n">candidate_value</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">extensions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">can_extend</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">best</span><span class="p">):</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">candidate</span> <span class="o">+</span> <span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="n">extensions</span> <span class="o">-</span> <span class="p">{</span><span class="n">item</span><span class="p">},</span> <span class="n">instance</span><span class="p">,</span> <span class="n">best</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../32_Answers/Answers_22_5_04.html"><span class="doc">Answer</span></a></p>
<p>Finally uncomment the next line and run it to check your solution.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># tsp(example) in [ [0,3,1,2,4,0], [0,4,2,1,3,0] ]</span>
</pre></div>
</div>
</div>
<p>The current algorithm still does much wasted work. It keeps extending paths where the second node 0 appears early on, only to later fail the global constraint test. The next exercise asks you to avoid generating such paths.</p>
<div class="admonition warning">
<p><strong>Note:</strong> After applying backtracking, look at the candidates generated and think if there are problem-specific ways of further pruning the search space.</p>
</div>
</section>
<section id="Exercise-22.5.5">
<h3>Exercise 22.5.5<a class="headerlink" href="#Exercise-22.5.5" title="Link to this heading"></a></h3>
<p>Make a copy of your <code class="docutils literal notranslate"><span class="pre">extend</span></code> function and change it so that a path is extended with node 0 only if it’s the last remaining extension. This guarantees that all complete candidates end with node 0 and you can remove the call to the global constraint check.</p>
<p>Run the example again to see a substantial reduction in the search space.</p>
<p><a class="reference internal" href="../32_Answers/Answers_22_5_05.html"><span class="doc">Answer</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="22_4_optimising.html" class="btn btn-neutral float-left" title="22.4. Optimise" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="22_6_subsets.html" class="btn btn-neutral float-right" title="22.6. Generate subsets" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>