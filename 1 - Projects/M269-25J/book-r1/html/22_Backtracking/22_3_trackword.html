

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>22.3. Trackword</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="22.4. Optimise" href="22_4_optimising.html" />
    <link rel="prev" title="22.2. Prune the search space" href="22_2_pruning.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="22-introduction.html">22. Backtracking</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="22_1_sequences.html">22.1. Generate sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_2_pruning.html">22.2. Prune the search space</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">22.3. Trackword</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#The-problem">22.3.1. The problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Candidates-and-extensions">22.3.2. Candidates and extensions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#The-constraints">22.3.3. The constraints</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.3.1-(optional)">Exercise 22.3.1 (optional)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-22.3.2-(optional)">Exercise 22.3.2 (optional)</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Template">22.3.4. Template</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="22_4_optimising.html">22.4. Optimise</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_5_tsp.html">22.5. Back to the TSP</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_6_subsets.html">22.6. Generate subsets</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_7_knapsack.html">22.7. Back to the knapsack</a></li>
<li class="toctree-l2"><a class="reference internal" href="22_8_summary.html">22.8. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="22-introduction.html"><span class="section-number">22. </span>Backtracking</a></li>
      <li class="breadcrumb-item active"><span class="section-number">22.3. </span>Trackword</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Trackword">
<h1><span class="section-number">22.3. </span>Trackword<a class="headerlink" href="#Trackword" title="Link to this heading"></a></h1>
<p>Trackword is a puzzle to find as many words with three to nine letters as we can in a 3×3 grid of letters. We can start in any square and move to any adjacent square, without visiting any square twice. The grid always contains a 9-letter word.</p>
<p>Here’s an example created by a <a class="reference external" href="http://happysoft.org.uk/countdown/trackword.php">fan site</a>. The figure shows the grid, the path for the 9-letter word ‘retrieves’ and two paths for the word ‘tree’. The grid also includes words ire, set, tee, sever, reset, reverse, serve, etc.</p>
<p id="fig-22.3.1"></p><p><a class="reference internal" href="../33_Figures/Figures_22_3.html#Figure-22.3.1"><span class="std std-ref">Figure 22.3.1</span></a></p>
<img alt="Image 22_3_trackword.png" src="../_images/22_3_trackword.png" />
<p>For this and other word problems we need a list of valid words. The notebooks folder for this chapter includes the public-domain Enable list, which contains long and inflected words (past tense, plural, etc.). The words in the list are in lowercase, so the grid will be in lowercase too.</p>
<div class="admonition note">
<p><strong>Info:</strong> Enable and other word lists are available from the <a class="reference external" href="http://wiki.puzzlers.org/dokuwiki/doku.php?id=solving:wordlists:about:start&amp;s=wordlist">The National Puzzler’s League</a>.</p>
</div>
<p>The following code reads words with three to nine letters from the file. It uses Python constructs outside the scope of M269.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">vocabulary</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;enable1.txt&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">file</span><span class="p">:</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">file</span><span class="p">:</span>
        <span class="n">word</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="mi">3</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">word</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">9</span><span class="p">:</span>
            <span class="n">vocabulary</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">word</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Let’s solve this problem with backtracking. I will ask you to think along with ‘stop and think’ lines.</p>
<section id="The-problem">
<h2><span class="section-number">22.3.1. </span>The problem<a class="headerlink" href="#The-problem" title="Link to this heading"></a></h2>
<p>The first thing to ponder is whether this problem is adequate for backtracking:</p>
<ol class="arabic simple">
<li><p>Is this a constraint satisfaction problem on sequences of unique items? If so, what are the sequences, why are items unique and what are the other constraints?</p></li>
</ol>
<hr class="docutils" />
<p>Yes, it is. We want to find all sequences of squares subject to these constraints: the length of the sequence is three to nine, the sequence is a valid path and the letters on the squares form a word. No square can be visited twice so the sequence has no duplicate squares.</p>
<ol class="arabic simple" start="2">
<li><p>Which of the constraints are global and which are local?</p></li>
</ol>
<hr class="docutils" />
<p>The global constraints are that the sequence forms a word and the word comprises three to nine letters. The local constraint is that each square in the sequence (except the first one) must be adjacent to the previous one.</p>
<div class="admonition warning">
<p><strong>Note:</strong> Backtracking is usually applicable to problems involving paths on 2D grids.</p>
</div>
</section>
<section id="Candidates-and-extensions">
<h2><span class="section-number">22.3.2. </span>Candidates and extensions<a class="headerlink" href="#Candidates-and-extensions" title="Link to this heading"></a></h2>
<p>Let’s start solving this problem. The core of backtracking is to extend a candidate sequence with one item at a time, taken from an initial set with all possible extensions. So the obvious starting questions to solve a problem are:</p>
<ol class="arabic simple">
<li><p>What are the candidates? What do they represent?</p></li>
<li><p>What are the items in the candidates? What do items represent?</p></li>
</ol>
<hr class="docutils" />
<ol class="arabic simple">
<li><p>There are only two options for what a candidate can be: the string of letters or the path of squares visited so far. As the example at the start shows, there may be several paths associated to the same string. If a candidate were a string, we couldn’t determine which squares can be visited next. The candidates are therefore paths: each one is a sequence of squares visited.</p></li>
<li><p>Each item represents a square of the grid.</p></li>
</ol>
<p>Once we have thought what each item represents in the problem, we need to think how to represent each item in the solution.</p>
<ol class="arabic simple" start="3">
<li><p>What data structure should we use for each item?</p></li>
<li><p>What is the initial set of all possible extensions? How can it be generated?</p></li>
</ol>
<hr class="docutils" />
<ol class="arabic simple" start="3">
<li><p>We can store each square as a pair of integers with the square’s row-column coordinates.</p></li>
<li><p>The initial extensions are all 9 squares of the grid. They can be generated with a nested loop iterating over all rows and columns of the grid.</p></li>
</ol>
<p>At this point we know the problem’s inputs and the initial extensions, which is enough to write the main function. I always pass the problem’s inputs to the backtracking function because it may need them to check the global and local constraints.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">trackword</span><span class="p">(</span><span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all words found in the grid, in the order generated.</span>

<span class="sd">    Preconditions:</span>
<span class="sd">    - grid is a 3 by 3 table of lowercase letters</span>
<span class="sd">    - valid is a set of strings of allowed words</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">path</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># the initial candidate</span>
    <span class="n">squares</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># the extensions</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">squares</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span>
    <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extend</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">squares</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">solutions</span>
</pre></div>
</div>
</div>
<p>The backtracking algorithm needs an extra if-statement if only complete candidates can be solutions, so the next thing to consider is:</p>
<ol class="arabic simple" start="5">
<li><p>Which candidates are solutions: only complete candidates or both complete and partial candidates?</p></li>
</ol>
<hr class="docutils" />
<p>The words in the grid can be of any length from 3 to 9, so both partial and complete paths may be solutions.</p>
<p>We can now write the backtracking algorithm, because it’s boilerplate code that calls two auxiliary functions, passing them the problem’s input in case they need it.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">squares</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extend the path with the squares. Add valid words to solutions.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_word</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">valid</span><span class="p">):</span>  <span class="c1"># check the global constraints</span>
        <span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>As I write the last line I stop in my tracks. The candidates are paths in the grid, but the problem asks for the words, so I must convert each path of squares to the corresponding string of letters.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">path_to_string</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the sequence of letters visited by the path in the grid.&quot;&quot;&quot;</span>
    <span class="n">string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">for</span> <span class="n">square</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
        <span class="n">string</span> <span class="o">=</span> <span class="n">string</span> <span class="o">+</span> <span class="n">grid</span><span class="p">[</span><span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">string</span>
</pre></div>
</div>
</div>
<p>Now I can write the complete backtracking algorithm.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">squares</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Extend the path with the squares. Add valid words to solutions.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">is_word</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">valid</span><span class="p">):</span>
        <span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path_to_string</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">grid</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">square</span> <span class="ow">in</span> <span class="n">squares</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">can_extend</span><span class="p">(</span><span class="n">square</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">valid</span><span class="p">):</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="n">square</span><span class="p">],</span> <span class="n">squares</span> <span class="o">-</span> <span class="p">{</span><span class="n">square</span><span class="p">},</span> <span class="n">grid</span><span class="p">,</span> <span class="n">valid</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Finally, let’s implement the auxiliary functions.</p>
</section>
<section id="The-constraints">
<h2><span class="section-number">22.3.3. </span>The constraints<a class="headerlink" href="#The-constraints" title="Link to this heading"></a></h2>
<p>The global constraints on a path are: it has three to nine letters and they form a valid word. Since only words with three to nine letters were read from the file, I can simply check if the path forms a word.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">is_word</span><span class="p">(</span><span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if the letters in the path form a valid word.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">path_to_string</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">grid</span><span class="p">)</span> <span class="ow">in</span> <span class="n">valid</span>
</pre></div>
</div>
</div>
<p>As for the local constraint, we must check if the next square is adjacent to the last square in the path so far. If the path is empty, it can be extended with any square.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">can_extend</span><span class="p">(</span><span class="n">square</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">grid</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">valid</span><span class="p">:</span> <span class="nb">set</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if square is adjacent to the last square of path.&quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">path</span> <span class="o">==</span> <span class="p">[]:</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">last_square</span> <span class="o">=</span> <span class="n">path</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">last_row</span> <span class="o">=</span> <span class="n">last_square</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">last_column</span> <span class="o">=</span> <span class="n">last_square</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">square</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">column</span> <span class="o">=</span> <span class="n">square</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">row</span> <span class="o">-</span> <span class="n">last_row</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="ow">and</span> <span class="nb">abs</span><span class="p">(</span><span class="n">column</span> <span class="o">-</span> <span class="n">last_column</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<p>That’s it! Let’s check it works. There are probably many words in this grid, so let’s just see a few of them.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">words</span> <span class="o">=</span> <span class="n">trackword</span><span class="p">([</span><span class="s2">&quot;set&quot;</span><span class="p">,</span> <span class="s2">&quot;err&quot;</span><span class="p">,</span> <span class="s2">&quot;vei&quot;</span><span class="p">],</span> <span class="n">vocabulary</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Total paths:&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Found 9-letter word?&quot;</span><span class="p">,</span> <span class="s2">&quot;retrieves&quot;</span> <span class="ow">in</span> <span class="n">words</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;First 10:&quot;</span><span class="p">,</span> <span class="n">words</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Total paths: 156
Found 9-letter word? True
First 10: [&#39;ere&#39;, &#39;err&#39;, &#39;errs&#39;, &#39;err&#39;, &#39;ere&#39;, &#39;ers&#39;, &#39;ere&#39;, &#39;eerie&#39;, &#39;eerier&#39;, &#39;res&#39;]
</pre></div></div>
</div>
<p>Some words occur repeatedly in the output list because there are various paths to obtain them. We can easily compute how many unique words there are:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">words</span><span class="p">))</span>  <span class="c1"># convert to set to remove duplicates</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
59
</pre></div></div>
</div>
<section id="Exercise-22.3.1-(optional)">
<h3>Exercise 22.3.1 (optional)<a class="headerlink" href="#Exercise-22.3.1-(optional)" title="Link to this heading"></a></h3>
<p>Looking at the code again, two improvements come to my mind. First, return a set instead of a sequence of words, to avoid duplicates. Second, remove unnecessary parameters. For example, function <code class="docutils literal notranslate"><span class="pre">can_extend</span></code> doesn’t need the <code class="docutils literal notranslate"><span class="pre">grid</span></code> and <code class="docutils literal notranslate"><span class="pre">valid</span></code> arguments.</p>
<p>Copy all functions to the cell below, make the suggested changes and any others you wish and run the code to check it still finds 59 words in the grid.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># copy the functions to here</span>

<span class="nb">len</span><span class="p">(</span><span class="n">trackword</span><span class="p">([</span><span class="s2">&quot;set&quot;</span><span class="p">,</span> <span class="s2">&quot;err&quot;</span><span class="p">,</span> <span class="s2">&quot;vei&quot;</span><span class="p">],</span> <span class="n">vocabulary</span><span class="p">))</span> <span class="o">==</span> <span class="mi">59</span>
</pre></div>
</div>
</div>
</section>
<section id="Exercise-22.3.2-(optional)">
<h3>Exercise 22.3.2 (optional)<a class="headerlink" href="#Exercise-22.3.2-(optional)" title="Link to this heading"></a></h3>
<p>Implement a more substantial change: represent each candidate as a sequence–string pair. This is a space–time tradeoff to avoid repeatedly converting a path to a string. When extending a candidate, append a square to the sequence and the corresponding letter to the string.</p>
</section>
</section>
<section id="Template">
<h2><span class="section-number">22.3.4. </span>Template<a class="headerlink" href="#Template" title="Link to this heading"></a></h2>
<p>In general, to solve a problem with backtracking, first think of what the items, candidates and extensions represent and which are the global and local constraints. Then follow this backtracking solution template, replacing the generic function and variable names and docstrings with problem-specific ones, and removing unnecessary parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">problem</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all solutions for the problem instance, in the order generated.&quot;&quot;&quot;</span>
    <span class="n">candidate</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extensions</span> <span class="o">=</span> <span class="o">...</span>
    <span class="n">solutions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">extend</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">extensions</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">solutions</span>

<span class="k">def</span><span class="w"> </span><span class="nf">extend</span><span class="p">(</span><span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">extensions</span><span class="p">:</span> <span class="nb">set</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add to solutions all extensions of candidate that solve the problem instance.&quot;&quot;&quot;</span>
    <span class="c1"># remove next line if partial candidates can be solutions</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">extensions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">satisfies_global</span><span class="p">(</span><span class="n">candidate</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
            <span class="n">solutions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">extensions</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">can_extend</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="n">candidate</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
            <span class="n">extend</span><span class="p">(</span><span class="n">candidate</span> <span class="o">+</span> <span class="p">[</span><span class="n">item</span><span class="p">],</span> <span class="n">extensions</span> <span class="o">-</span> <span class="p">{</span><span class="n">item</span><span class="p">},</span> <span class="n">instance</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

<span class="k">def</span><span class="w"> </span><span class="nf">satisfies_global</span><span class="p">(</span><span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if candidate satisfies the global constraints.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>

<span class="k">def</span><span class="w"> </span><span class="nf">can_extend</span><span class="p">(</span><span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">,</span> <span class="n">candidate</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Check if item may extend candidate towards a solution.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">...</span>
</pre></div>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="22_2_pruning.html" class="btn btn-neutral float-left" title="22.2. Prune the search space" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="22_4_optimising.html" class="btn btn-neutral float-right" title="22.4. Optimise" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>