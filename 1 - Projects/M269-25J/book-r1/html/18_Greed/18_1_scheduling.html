

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>18.1. Interval scheduling</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="18.2. Weighted graphs" href="18_2_weighted_graph.html" />
    <link rel="prev" title="18. Greed" href="18-introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="18-introduction.html">18. Greed</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">18.1. Interval scheduling</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#The-greedy-approach">18.1.1. The greedy approach</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Greedy-choices">18.1.2. Greedy choices</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-18.1.1">Exercise 18.1.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Algorithm">18.1.3. Algorithm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-18.1.2">Exercise 18.1.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-18.1.3-(optional)">Exercise 18.1.3 (optional)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-18.1.4-(optional)">Exercise 18.1.4 (optional)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="18_2_weighted_graph.html">18.2. Weighted graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="18_3_mst.html">18.3. Minimum spanning tree</a></li>
<li class="toctree-l2"><a class="reference internal" href="18_4_shortest_path.html">18.4. Shortest paths</a></li>
<li class="toctree-l2"><a class="reference internal" href="18_5_summary.html">18.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="18-introduction.html"><span class="section-number">18. </span>Greed</a></li>
      <li class="breadcrumb-item active"><span class="section-number">18.1. </span>Interval scheduling</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Interval-scheduling">
<h1><span class="section-number">18.1. </span>Interval scheduling<a class="headerlink" href="#Interval-scheduling" title="Link to this heading"></a></h1>
<p>After a long lockdown, Alice is keen to attend as many music festivals as possible. She has the start and end date of each festival she’d like to attend. What is a largest subset of festivals she can attend?</p>
<p>Consider groups of people trying to book a particular room for their meetings. Given the start and end time of each meeting, what’s the largest number of meetings that can be scheduled for that room?</p>
<p>In general, the <strong>interval scheduling</strong> problem is: given a set of time intervals, find a largest subset without overlaps. Two time intervals overlap if they have at least one time point in common, e.g. if the end time of one interval is part of the other interval.</p>
<p>To simplify, I will represent time points as natural numbers and time intervals as pairs of start–end points, e.g. (3, 5) is the interval starting at time point 3 and ending at time point 5.</p>
<div class="line-block">
<div class="line"><strong>Operation:</strong> largest interval schedule</div>
<div class="line"><strong>Inputs:</strong> <em>intervals</em>, a set of pairs of natural numbers</div>
<div class="line"><strong>Preconditions:</strong> for every pair (<em>start</em>, <em>end</em>), <em>start</em> &lt; <em>end</em></div>
<div class="line"><strong>Output:</strong> <em>schedule</em>, a set of pairs of natural numbers</div>
<div class="line"><strong>Postconditions:</strong></div>
</div>
<ul class="simple">
<li><p><em>schedule</em> is a subset of <em>intervals</em></p></li>
<li><p>for any (<span class="math notranslate nohighlight">\(s_1\)</span>, <span class="math notranslate nohighlight">\(e_1\)</span>) ≠ (<span class="math notranslate nohighlight">\(s_2\)</span>, <span class="math notranslate nohighlight">\(e_2\)</span>) in <em>schedule</em>, either <span class="math notranslate nohighlight">\(e_1\)</span> &lt; <span class="math notranslate nohighlight">\(s_2\)</span> or <span class="math notranslate nohighlight">\(e_2\)</span> &lt; <span class="math notranslate nohighlight">\(s_1\)</span></p></li>
<li><p>no subset of <em>intervals</em> satisfying condition 2 is larger than <em>schedule</em></p></li>
</ul>
<p>The second postcondition states that for any two intervals in the solution, one must end before the other starts. The third postcondition states that the output has as many intervals as possible.</p>
<p>The problem definition uses the word ‘Operation’ instead of ‘Function’ because we’re not defining a mathematical function: a set of intervals may lead to several largest schedules as the next table shows. An algorithm can return any of them.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Case</p></th>
<th class="head"><p><em>intervals</em></p></th>
<th class="head"><p><em>schedule</em></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>no intervals</p></td>
<td><p>{}</p></td>
<td><p>{}</p></td>
</tr>
<tr class="row-odd"><td><p>one interval</p></td>
<td><p>{(9, 17)}</p></td>
<td><p>{(9, 17)}</p></td>
</tr>
<tr class="row-even"><td><p>no overlap</p></td>
<td><p>{(4, 5), (0, 1), (2, 3)}</p></td>
<td><p>{(4, 5), (0, 1), (2, 3)}</p></td>
</tr>
<tr class="row-odd"><td><p>some overlap</p></td>
<td><p>{(6, 10), (9, 17), (0, 5)}</p></td>
<td><p>{(6, 10), (0, 5)} or {(9, 17), (0, 5)}</p></td>
</tr>
<tr class="row-even"><td><p>all overlap</p></td>
<td><p>{(3, 5), (5, 6), (2, 7)}</p></td>
<td><p>{(3, 5)} or {(5, 6)} or {(2, 7)}</p></td>
</tr>
</tbody>
</table>
<section id="The-greedy-approach">
<h2><span class="section-number">18.1.1. </span>The greedy approach<a class="headerlink" href="#The-greedy-approach" title="Link to this heading"></a></h2>
<p>A greedy algorithm constructs the output collection one item at a time. It first finds all items that are compatible with the choices made so far. For the knapsack problem, it’s those items that still fit in the knapsack. For interval scheduling, it’s those intervals that don’t overlap any already scheduled interval. I will call those items the <em>extensions</em> to the current partial solution.</p>
<p>Once the algorithm has computed the extensions, it makes a <strong>greedy choice</strong>: it chooses the best extension, or a single best one if there are several equally good options. The criterion used by the greedy choice is the crux of the algorithm; I’ll come to it later.</p>
<p>The algorithm continues choosing a best item among those compatible with previous choices, until the solution is complete. This is certainly the case when no more items are available, but depending on the problem the solution may be completed earlier.</p>
<p>A general algorithmic pattern for greedy algorithms is:</p>
<ol class="arabic simple">
<li><p>let <em>solution</em> be an empty collection</p></li>
<li><p>repeat:</p>
<ol class="arabic simple">
<li><p>let <em>extensions</em> be the possible next items compatible with <em>solution</em></p></li>
<li><p>if <em>extensions</em> isn’t empty:</p>
<ol class="arabic simple">
<li><p>add one of the best of <em>extensions</em> to <em>solution</em></p></li>
</ol>
</li>
</ol>
</li>
<li><p>until <em>extensions</em> is empty</p></li>
</ol>
<p>This algorithm is computing the extensions from scratch in each iteration. Often, we know the possible extensions in advance (they’re the input items) and we just want to add the next best one to the solution. I gave an example in the introduction: we take the next most valuable item and put it in the knapsack if it fits.</p>
<p>For such problems, a more efficient greedy algorithm constructs the extensions once, by sorting the input items from best to worst. It then keeps picking the next best item, checks if it’s compatible with the partial solution, and if so extends the solution with that item.</p>
<ol class="arabic simple">
<li><p>let <em>solution</em> be an empty collection</p></li>
<li><p>let <em>extensions</em> be the input items sorted from best to worst</p></li>
<li><p>for each <em>item</em> in <em>extensions</em>:</p>
<ol class="arabic simple">
<li><p>if <em>item</em> is compatible with <em>solution</em>:</p>
<ol class="arabic simple">
<li><p>add <em>item</em> to <em>solution</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>The greedy algorithm I outlined in the introduction for the knapsack problem is:</p>
<ol class="arabic simple">
<li><p>let <em>solution</em> be the empty set</p></li>
<li><p>let <em>extensions</em> be the input items sorted from most to least valuable</p></li>
<li><p>for each <em>item</em> in <em>extensions</em>:</p>
<ol class="arabic simple">
<li><p>if weight of <em>item</em> + weight of <em>solution</em> ≤ capacity of knapsack:</p>
<ol class="arabic simple">
<li><p>add <em>item</em> to <em>solution</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
<div class="admonition warning">
<p><strong>Note:</strong> Greedy algorithms sometimes involve sorting the input.</p>
</div>
<p>Exhaustive search generates all possible candidates (unless it can stop early), to make sure it finds the best one. Greedy algorithms generate a single candidate: they don’t explore alternatives. They can’t be used when the problem asks for several best solution, e.g. if we wanted to know all largest subsets of non-overlapping intervals.</p>
<p>Exhaustive search generates in each iteration a complete candidate and tests it. Greedy algorithms extend a partial candidate by one item per iteration and they don’t test the candidate at the end. If the greedy choice is correct, the generated candidate is a best solution.</p>
</section>
<section id="Greedy-choices">
<h2><span class="section-number">18.1.2. </span>Greedy choices<a class="headerlink" href="#Greedy-choices" title="Link to this heading"></a></h2>
<p>Let’s now think about the greedy choice for the interval scheduling problem.</p>
<p>We want to select as many intervals as possible. One possible choice is to select the interval that starts earliest, so that we’re not idle. Consider the intervals in the following figure.</p>
<p id="fig-18.1.1"></p><p><a class="reference internal" href="../33_Figures/Figures_18_1.html#Figure-18.1.1"><span class="std std-ref">Figure 18.1.1</span></a></p>
<img alt="Image 18_1_by_start.png" src="../_images/18_1_by_start.png" />
<p>Processing them by ascending start time, i.e. from left to right in the figure, the algorithm:</p>
<ol class="arabic simple">
<li><p>adds (1, 4) to the empty schedule</p></li>
<li><p>skips (3, 7) because it overlaps with (1, 4)</p></li>
<li><p>adds (5, 6) to the schedule because it doesn’t overlap (1, 4)</p></li>
<li><p>skips (6, 7) because it overlaps (5, 6) at time point 6.</p></li>
</ol>
<p>The algorithm produces the schedule {(1,4), (5,6)}; it’s a correct solution. No schedule with three intervals is possible.</p>
<p>Unfortunately, choosing the earliest start doesn’t always lead to a solution, as the next figure shows. The long interval C starts first but choosing it prevents finding the largest schedule, with intervals A and B.</p>
<p id="fig-18.1.2"></p><p><a class="reference internal" href="../33_Figures/Figures_18_1.html#Figure-18.1.2"><span class="std std-ref">Figure 18.1.2</span></a></p>
<img alt="Image 18_1_long.png" src="../_images/18_1_long.png" />
<p>Well, if a single long interval prevents choosing several smaller intervals, let’s choose as the best interval the shortest one. Alas, this isn’t correct either, as the next figure shows. The shortest interval, C, overlaps intervals A and B at two time points: C starts when A ends and C ends when B starts. Therefore, choosing C first prevents finding the largest schedule {A, B}.</p>
<p id="fig-18.1.3"></p><p><a class="reference internal" href="../33_Figures/Figures_18_1.html#Figure-18.1.3"><span class="std std-ref">Figure 18.1.3</span></a></p>
<img alt="Image 18_1_short.png" src="../_images/18_1_short.png" />
<p>These counter-examples suggest we should choose the interval with the fewest overlaps, to remove the fewest other intervals. This sounds reasonable, but there’s a counter-example for that. Consider the nine intervals in the following figure.</p>
<p id="fig-18.1.4"></p><p><a class="reference internal" href="../33_Figures/Figures_18_1.html#Figure-18.1.4"><span class="std std-ref">Figure 18.1.4</span></a></p>
<img alt="Image 18_1_intervals.png" src="../_images/18_1_intervals.png" />
<p>All intervals except E and G overlap two other intervals. The algorithm could choose any of them first, but if it chooses F, which eliminates B and C, the algorithm will only find a three-interval subset like {A, F, I} and not a four-interval solution like {A, B, C, D}.</p>
<p>Another possible choice is to pick the interval ending soonest, as that maximises the remaining time, allowing more intervals to be picked. Sorting the nine intervals by end time we get sequence (A, H, E, B, F, C, G, I, D). The algorithm adds A, skips H and E because they overlap A, adds B and thus skips F, adds C and then skips G, and finally adds I which forces D to be skipped. The output schedule is {A, B, C, I}, which satisfies the postconditions.</p>
<p>Choosing the interval ending soonest always leads to a largest subset. To understand why, consider the following diagram where <em>t</em> is the lowest ending time of all intervals.</p>
<p id="fig-18.1.5"></p><p><a class="reference internal" href="../33_Figures/Figures_18_1.html#Figure-18.1.5"><span class="std std-ref">Figure 18.1.5</span></a></p>
<img alt="Image 18_1_proof.png" src="../_images/18_1_proof.png" />
<p>Each interval belongs to one of three groups:</p>
<ul class="simple">
<li><p>it ends at <em>t</em>, like intervals A, B, and C</p></li>
<li><p>it starts before <em>t</em> and ends after <em>t</em>, like intervals D and E</p></li>
<li><p>it starts after <em>t</em>, like intervals F, G and H.</p></li>
</ul>
<p>All intervals in the first two groups overlap each other, so the largest schedule has at most one of them, no matter how the intervals are chosen. If the algorithm chooses an interval in the second group, it may overlap with an interval in the third group, e.g. E overlaps with F, whereas the first and third groups never overlap. Thus, choosing any of the intervals ending soonest, at <em>t</em>, doesn’t lead to fewer intervals in the schedule than any other choice, which means it’s a largest schedule.</p>
<div class="admonition warning">
<p><strong>Note:</strong> Usually, there are several greedy choices for a problem, but possibly only one (or even none) will lead to a correct solution.</p>
</div>
<p>Proving that a greedy algorithm is correct can be hard; you won’t be asked to do it. Proving that it’s incorrect is usually relatively easy because a single counter-example will do. In his book <em>The Algorithm Design Manual</em>, Steven Skiena suggests four approaches for coming up with counter-examples.</p>
<ul class="simple">
<li><p>Think small: Algorithms fail under very particular conditions, which can be illustrated with small problem instances.</p></li>
<li><p>Think exhaustively: There are only three ways to combine intervals (overlap, containment, disjoint); they can be used to construct examples systematically, e.g. one interval overlaps and thereby eliminates two other intervals.</p></li>
<li><p>Go for a tie: Greedy algorithms choose the best extension, but if there are several best ones, the algorithm may choose the wrong one.</p></li>
<li><p>Seek extremes: Counter-examples sometimes include items with opposite properties, like small and large, or long and short. For example, a long interval prevents choosing several small ones.</p></li>
</ul>
<div class="admonition warning">
<p><strong>Note:</strong> Try constructing counter-examples that are small, contain items that are tied for being the best, or contain extreme items.</p>
</div>
<p>A counter-example reveals subtle conditions that make one greedy choice lead to an incorrect output. Thus they’re good tests to check other greedy choices. For example, I checked the correct choice (interval ending soonest) on the counter-example for choosing the interval with fewest overlaps. You can check that the correct greedy choice also handles the counter-examples for choosing the interval starting soonest and for choosing the shortest interval.</p>
<div class="admonition warning">
<p><strong>Note:</strong> As you think of possible greedy choices, add counter-examples to a test table and check each greedy choice against them.</p>
</div>
<section id="Exercise-18.1.1">
<h3>Exercise 18.1.1<a class="headerlink" href="#Exercise-18.1.1" title="Link to this heading"></a></h3>
<p>In the introduction, I gave a greedy choice for the 0/1 knapsack problem: at each step take the most valuable remaining item that fits the knapsack. To do that we can initially sort the items by descending value. I also showed a counter-example for this choice.</p>
<p>Here are two other greedy choices:</p>
<ol class="arabic simple">
<li><p>Take the lightest item to keep space for more items, i.e. sort by ascending weight.</p></li>
<li><p>Take the most profitable item, i.e. sort by descending value-to-weight ratio.</p></li>
</ol>
<p>For each greedy choice, provide a counter-example: a set of items and a knapsack capacity for which the greedy choice won’t maximise the value of the items that can be carried.</p>
<p><a class="reference internal" href="../32_Answers/Answers_18_1_01.html"><span class="doc">Answer</span></a></p>
</section>
</section>
<section id="Algorithm">
<h2><span class="section-number">18.1.3. </span>Algorithm<a class="headerlink" href="#Algorithm" title="Link to this heading"></a></h2>
<p>Now that we have a greedy choice that leads to a largest schedule, we can apply the second greedy algorithmic pattern to interval scheduling, because the possible extensions are the intervals given in the input.</p>
<ol class="arabic simple">
<li><p>let <em>schedule</em> be the empty set</p></li>
<li><p>let <em>extensions</em> be <em>intervals</em> in ascending end time</p></li>
<li><p>for each <em>interval</em> in <em>extensions</em>:</p>
<ol class="arabic simple">
<li><p>if <em>interval</em> is compatible with <em>schedule</em>:</p>
<ol class="arabic simple">
<li><p>add <em>interval</em> to <em>schedule</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>One way to implement step 3.1 is to check if the extension interval doesn’t overlap any already scheduled interval. That takes linear time in the size of the partial schedule. We should try to exploit the sorted order for a more efficient approach.</p>
<p>When explaining why the algorithm is correct, I noted that only the intervals starting after the soonest ending time <em>t</em> are compatible with the intervals ending at <em>t</em>. So, if we keep the end time of the latest interval scheduled so far, we can easily check if the extension interval being considered is compatible.</p>
<ol class="arabic simple">
<li><p>let <em>schedule</em> be the empty set</p></li>
<li><p>let <em>extensions</em> be the <em>intervals</em> in ascending end time</p></li>
<li><p>let <em>last</em> be −1</p></li>
<li><p>for each <em>interval</em> in <em>extensions</em>:</p>
<ol class="arabic simple">
<li><p>if the start of <em>interval</em> &gt; <em>last</em>:</p>
<ol class="arabic simple">
<li><p>add <em>interval</em> to <em>schedule</em></p></li>
<li><p>let <em>last</em> be the end of <em>interval</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>What’s a worst-case scenario for this algorithm?</p>
<hr class="docutils" />
<p>The algorithm does most work when no pair of intervals overlaps. In that scenario, the algorithm adds all intervals to the schedule.</p>
<section id="Exercise-18.1.2">
<h3>Exercise 18.1.2<a class="headerlink" href="#Exercise-18.1.2" title="Link to this heading"></a></h3>
<p>What’s the worst-case complexity of the algorithm? Use <em>i</em> = │<em>intervals</em>│ for the size of the input.</p>
<p><a class="reference internal" href="../32_Answers/Answers_18_1_02.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-18.1.3-(optional)">
<h3>Exercise 18.1.3 (optional)<a class="headerlink" href="#Exercise-18.1.3-(optional)" title="Link to this heading"></a></h3>
<p>Implement and test the algorithm. Write a test table with the above problem instances and counter-examples.</p>
</section>
<section id="Exercise-18.1.4-(optional)">
<h3>Exercise 18.1.4 (optional)<a class="headerlink" href="#Exercise-18.1.4-(optional)" title="Link to this heading"></a></h3>
<p>To appreciate how efficient the greedy approach is, outline an exhaustive search algorithm and explain its worst-case complexity.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="18-introduction.html" class="btn btn-neutral float-left" title="18. Greed" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="18_2_weighted_graph.html" class="btn btn-neutral float-right" title="18.2. Weighted graphs" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>