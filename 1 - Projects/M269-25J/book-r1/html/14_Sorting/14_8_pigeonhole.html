

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>14.8. Pigeonhole sort</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="14.9. Summary" href="14_9_summary.html" />
    <link rel="prev" title="14.7. Quicksort variants" href="14_7_quicksort_variants.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="14-introduction.html">14. Sorting</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="14_1_sort_prep.html">14.1. Preliminaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_2_bogosort.html">14.2. Bogosort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_3_insertion_sort.html">14.3. Insertion sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_4_selection_sort.html">14.4. Selection sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_5_merge_sort.html">14.5. Merge sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_6_quicksort.html">14.6. Quicksort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_7_quicksort_variants.html">14.7. Quicksort variants</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">14.8. Pigeonhole sort</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Comparison-sort-complexity">14.8.1. Comparison sort complexity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Algorithm">14.8.2. Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Complexity">14.8.3. Complexity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Code-and-tests">14.8.4. Code and tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Performance">14.8.5. Performance</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="14_9_summary.html">14.9. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="14-introduction.html"><span class="section-number">14. </span>Sorting</a></li>
      <li class="breadcrumb-item active"><span class="section-number">14.8. </span>Pigeonhole sort</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Pigeonhole-sort">
<h1><span class="section-number">14.8. </span>Pigeonhole sort<a class="headerlink" href="#Pigeonhole-sort" title="Link to this heading"></a></h1>
<p>The algorithms presented so far are <strong>comparison sorts</strong>: they’re based on comparing pairs of items, or their keys. This section shows an example of a <strong>distribution sort</strong>, which first distributes the items based on their keys and then collects them in order. The reason for a different kind of sorting algorithm is efficiency.</p>
<section id="Comparison-sort-complexity">
<h2><span class="section-number">14.8.1. </span>Comparison sort complexity<a class="headerlink" href="#Comparison-sort-complexity" title="Link to this heading"></a></h2>
<p><a class="reference internal" href="../04_Iteration/04_6_lists.html#Creating-lists"><span class="std std-ref">Earlier</span></a> we assumed that sorting is linear in the best case, to check the input is already sorted, and quadratic in the worst case: comparing all items to each other should be enough to put each item in its correct place in the sequence.</p>
<p>Insertion sort is linear in the best case and quadratic in the worst case, as it has to compare each unsorted item to at least one and at most all previously sorted items. Selection sort is always quadratic because it compares each unsorted item to all other unsorted items.</p>
<p>Our earlier argument only posited that sorting doesn’t need more than quadratic time, but as we have meanwhile seen, human imagination is able to come up with worse solutions than needed (like bogosort) and with better solutions than expected (like merge sort, which is always log-linear). It turns out that log-linear is the lowest worst-case complexity for comparison sorts, as I’ll show next.</p>
<p>Let’s assume the <em>n</em> items have unique keys. Therefore, there’s a single ascending permutation. As bogosort did, we can see sorting as searching for the one permutation that is sorted.</p>
<p>If for example we find out that key(A) &lt; key(B), we can discard all permutations where item A comes after (to the right of) item B, because those aren’t sorted. For each permutation to be removed from the search space, because A and B are in the wrong order, there’s exactly one other permutation that is kept in the search space, because it’s equal except that A and B swapped places and hence are in the correct order. In summary, every comparison gives enough information to discard half the
search space.</p>
<p>After one comparison the search space has <em>n</em>! / 2 permutations. After two comparisons it has <em>n</em>!/2/2 = <em>n</em>!/2² permutations. In general, after <em>c</em> comparisons, the search space has size <em>n</em>!/<span class="math notranslate nohighlight">\(2^c\)</span>. The algorithm stops when the search space has one permutation (the sorted one), i.e. when <em>n</em>!/<span class="math notranslate nohighlight">\(2^c\)</span> = 1, which is the same as <em>n</em>! = <span class="math notranslate nohighlight">\(2^c\)</span> or <em>c</em> = log <em>n</em>!. It has been proven that log <em>n</em>! is about the same as <em>n</em> log <em>n</em> and so that’s the number of comparisons needed.</p>
</section>
<section id="Algorithm">
<h2><span class="section-number">14.8.2. </span>Algorithm<a class="headerlink" href="#Algorithm" title="Link to this heading"></a></h2>
<p>If we assume more about the sorting keys than just being comparable, then we can use more efficient sorting algorithms, like <strong>pigeonhole sort</strong>.</p>
<p>The algorithm gets its name from the pigeonholes used in mail sorting. You can see them at start of the second part of the <a class="reference external" href="https://learn2.open.ac.uk/mod/oucontent/view.php?id=2554724">BBC programme</a>. All mail to the same postcode, the sorting key, goes in the same pigeonhole. We need to know in advance the possible keys to create a pigeonhole for each.</p>
<p>Pigeonhole sort uses a map of keys to items with that key. This can be done with a lookup table of length <em>k</em> and a key function that returns natural numbers from 0 to <em>k</em> – 1. In the first phase (step 3 below) the algorithm distributes the items according to their keys. In the second phase (steps 4 and 5) it collects the items from lowest to highest key.</p>
<ol class="arabic simple">
<li><p>let <em>pigeonholes</em> be ()</p></li>
<li><p>repeat <em>k</em> times:</p>
<ol class="arabic simple">
<li><p>append an empty collection to <em>pigeonholes</em></p></li>
</ol>
</li>
<li><p>for each <em>item</em> in <em>unsorted</em>:</p>
<ol class="arabic simple">
<li><p>add <em>item</em> to <em>pigeonholes</em>[<em>key</em>(<em>item</em>)]</p></li>
</ol>
</li>
<li><p>let <em>sorted</em> be ()</p></li>
<li><p>for each <em>slot</em> in <em>pigeonholes</em>:</p>
<ol class="arabic simple">
<li><p>for each <em>item</em> in <em>slot</em>:</p>
<ol class="arabic simple">
<li><p>append <em>item</em> to <em>sorted</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
</section>
<section id="Complexity">
<h2><span class="section-number">14.8.3. </span>Complexity<a class="headerlink" href="#Complexity" title="Link to this heading"></a></h2>
<p>The algorithm only uses constant-time operations. Step 2.1 is done <em>k</em> times, steps 3 and 5.1.1 are each executed <em>n</em> times to add all items in unsorted order and retrieve them in sorted order. The complexity is thus Θ(<em>n</em> + <em>k</em>). Usually <em>k</em> is either a constant or a multiple of <em>n</em>, so the complexity of pigeonhole sort is linear in the length of the input.</p>
<p>Pigeonhole sort is based on the same idea as selection sort: at each step append the smallest unsorted item to the sorted items. The difference is that it uses natural number keys and a lookup table to select the minimum in constant instead of linear time. This enables pigeonhole sort to process <em>n</em> items in linear time, while selection sort takes quadratic time.</p>
</section>
<section id="Code-and-tests">
<h2><span class="section-number">14.8.4. </span>Code and tests<a class="headerlink" href="#Code-and-tests" title="Link to this heading"></a></h2>
<p>Pigeonhole requires an extra parameter to know how many slots to create.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>


<span class="k">def</span><span class="w"> </span><span class="nf">pigeonhole_sorted</span><span class="p">(</span><span class="n">unsorted</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">slots</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a permutation with keys in non-decreasing order.</span>

<span class="sd">    Precondition: for each item in unsorted 0 &lt;= key(item) &lt; slots</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pigeonholes</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">slots</span><span class="p">):</span>  <span class="c1"># noqa: B007</span>
        <span class="n">pigeonholes</span><span class="o">.</span><span class="n">append</span><span class="p">([])</span>
    <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">unsorted</span><span class="p">:</span>
        <span class="n">pigeonholes</span><span class="p">[</span><span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">slot</span> <span class="ow">in</span> <span class="n">pigeonholes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">slot</span><span class="p">:</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
</pre></div>
</div>
</div>
<p>I can’t reuse the <a class="reference internal" href="14_1_sort_prep.html#Problem-instances"><span class="std std-ref">same tests</span></a> as for the previous sorting algorithms because of the extra <code class="docutils literal notranslate"><span class="pre">slot</span></code> parameter and because the key functions don’t return natural numbers from 0 onwards. I must redefine the key functions and the test table. I will however use the same problem instances.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">test</span>

<span class="o">%</span><span class="k">run</span> -i ../m269_sorting


<span class="k">def</span><span class="w"> </span><span class="nf">value_nat</span><span class="p">(</span><span class="n">card</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return 0 to 12 for value A2...9TJQK respectively.</span>

<span class="sd">    Preconditions: as for function &#39;suit&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">value</span><span class="p">(</span><span class="n">card</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># the value function returns 1 to 13</span>


<span class="k">def</span><span class="w"> </span><span class="nf">suit_nat</span><span class="p">(</span><span class="n">card</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return 0 to 3 for suit &#39;C&#39;, &#39;D&#39;, &#39;H&#39; and &#39;S&#39; respectively.</span>

<span class="sd">    Preconditions: as for function &#39;suit&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;C&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;D&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;S&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">}[</span><span class="n">card</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">card_nat</span><span class="p">(</span><span class="n">card</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return 0 to 51 according to the sorted order of the card.</span>

<span class="sd">    Cards are sorted first by suit, then by value.</span>
<span class="sd">    Preconditions: as for function &#39;suit&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">suit_nat</span><span class="p">(</span><span class="n">card</span><span class="p">)</span> <span class="o">*</span> <span class="mi">13</span> <span class="o">+</span> <span class="n">value_nat</span><span class="p">(</span><span class="n">card</span><span class="p">)</span>


<span class="n">pigeonhole_sorted_tests</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># case,       unsorted,          key,    slots, sorted</span>
    <span class="p">(</span><span class="s1">&#39;no cards&#39;</span><span class="p">,</span>   <span class="p">[],</span>               <span class="n">card_nat</span><span class="p">,</span>  <span class="mi">52</span><span class="p">,</span> <span class="p">[]),</span>
    <span class="p">(</span><span class="s1">&#39;1 card&#39;</span><span class="p">,</span>     <span class="p">[</span><span class="s1">&#39;AS&#39;</span><span class="p">],</span>           <span class="n">card_nat</span><span class="p">,</span>  <span class="mi">52</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;AS&#39;</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;same card&#39;</span><span class="p">,</span>  <span class="p">[</span><span class="s1">&#39;6D&#39;</span><span class="p">,</span><span class="s1">&#39;6D&#39;</span><span class="p">],</span>      <span class="n">card_nat</span><span class="p">,</span>  <span class="mi">52</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;6D&#39;</span><span class="p">,</span><span class="s1">&#39;6D&#39;</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;3 cards&#39;</span><span class="p">,</span>    <span class="p">[</span><span class="s1">&#39;JC&#39;</span><span class="p">,</span><span class="s1">&#39;8D&#39;</span><span class="p">,</span><span class="s1">&#39;TS&#39;</span><span class="p">],</span> <span class="n">value_nat</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;8D&#39;</span><span class="p">,</span><span class="s1">&#39;TS&#39;</span><span class="p">,</span><span class="s1">&#39;JC&#39;</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;value up&#39;</span><span class="p">,</span>   <span class="n">UP_DOWN</span><span class="p">,</span>          <span class="n">value_nat</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="n">UP_DOWN</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;suit down&#39;</span><span class="p">,</span>  <span class="n">UP_DOWN</span><span class="p">,</span>          <span class="n">suit_nat</span><span class="p">,</span>   <span class="mi">4</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;KC&#39;</span><span class="p">,</span><span class="s1">&#39;QD&#39;</span><span class="p">,</span><span class="s1">&#39;3H&#39;</span><span class="p">,</span><span class="s1">&#39;AS&#39;</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;same value&#39;</span><span class="p">,</span> <span class="n">SAME_VALUE</span><span class="p">,</span>       <span class="n">card_nat</span><span class="p">,</span>  <span class="mi">52</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;TC&#39;</span><span class="p">,</span><span class="s1">&#39;TD&#39;</span><span class="p">,</span><span class="s1">&#39;TH&#39;</span><span class="p">,</span><span class="s1">&#39;TS&#39;</span><span class="p">]),</span>
<span class="p">]</span>

<span class="n">test</span><span class="p">(</span><span class="n">pigeonhole_sorted</span><span class="p">,</span> <span class="n">pigeonhole_sorted_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Testing pigeonhole_sorted...
Tests finished: 7 passed (100%), 0 failed.
</pre></div></div>
</div>
</section>
<section id="Performance">
<h2><span class="section-number">14.8.5. </span>Performance<a class="headerlink" href="#Performance" title="Link to this heading"></a></h2>
<p>Pigeonhole sort takes linear time on all inputs. Insertion sort is also linear when the input is sorted. Which do you expect to be faster for sorted inputs: insertion sort or pigeonhole sort?</p>
<hr class="docutils" />
<p>Insertion sort uses no extra data structure. It does no swaps and only one comparison if the item is in its sorted place, so it should be faster. Let’s eat the pudding, so to speak.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">doubling</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">doubling</span><span class="p">))</span>
    <span class="o">%</span><span class="k">timeit</span> -r 5 pigeonhole_sorted(items, identity, len(items))
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
10.8 μs ± 11.2 ns per loop (mean ± std. dev. of 5 runs, 100,000 loops each)
21.8 μs ± 39.2 ns per loop (mean ± std. dev. of 5 runs, 10,000 loops each)
44.2 μs ± 83.1 ns per loop (mean ± std. dev. of 5 runs, 10,000 loops each)
92.6 μs ± 293 ns per loop (mean ± std. dev. of 5 runs, 10,000 loops each)
187 μs ± 333 ns per loop (mean ± std. dev. of 5 runs, 10,000 loops each)
</pre></div></div>
</div>
<p>Comparing these values to <a class="reference internal" href="14_3_insertion_sort.html#Performance"><span class="std std-ref">those for insertion sort</span></a>, the latter is indeed slightly faster.</p>
<p>Pigeonhole not only has better complexity than comparison sorts, it’s also simpler: there are no recursive calls, swaps or partitions. It’s thus quite faster than our versions of <a class="reference internal" href="14_5_merge_sort.html#Code-and-performance"><span class="std std-ref">merge sort</span></a> or <a class="reference internal" href="14_6_quicksort.html#Code-and-performance"><span class="std std-ref">quicksort</span></a>, which aren’t in-place either.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="14_7_quicksort_variants.html" class="btn btn-neutral float-left" title="14.7. Quicksort variants" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="14_9_summary.html" class="btn btn-neutral float-right" title="14.9. Summary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>