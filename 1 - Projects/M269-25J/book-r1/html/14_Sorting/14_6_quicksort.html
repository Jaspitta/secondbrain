

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>14.6. Quicksort</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="14.7. Quicksort variants" href="14_7_quicksort_variants.html" />
    <link rel="prev" title="14.5. Merge sort" href="14_5_merge_sort.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="14-introduction.html">14. Sorting</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="14_1_sort_prep.html">14.1. Preliminaries</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_2_bogosort.html">14.2. Bogosort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_3_insertion_sort.html">14.3. Insertion sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_4_selection_sort.html">14.4. Selection sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_5_merge_sort.html">14.5. Merge sort</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">14.6. Quicksort</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Algorithm">14.6.1. Algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Complexity">14.6.2. Complexity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-14.6.1">Exercise 14.6.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Code-and-performance">14.6.3. Code and performance</a></li>
<li class="toctree-l3"><a class="reference internal" href="#In-place-version">14.6.4. In-place version</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="14_7_quicksort_variants.html">14.7. Quicksort variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_8_pigeonhole.html">14.8. Pigeonhole sort</a></li>
<li class="toctree-l2"><a class="reference internal" href="14_9_summary.html">14.9. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="14-introduction.html"><span class="section-number">14. </span>Sorting</a></li>
      <li class="breadcrumb-item active"><span class="section-number">14.6. </span>Quicksort</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Quicksort">
<h1><span class="section-number">14.6. </span>Quicksort<a class="headerlink" href="#Quicksort" title="Link to this heading"></a></h1>
<p>Like merge sort, <strong>quicksort</strong> divides the input sequence in two partitions, recursively sorts each partition and then puts them together. Whereas merge sort divides the sequence by position, in two halves, quicksort divides the items by key: those with smaller keys go into one partition, those with larger keys go in the other. After the partitions are sorted, they just have to be concatenated, which is much simpler than merging.</p>
<p>Insertion sort did less work than selection sort when splitting the input but more when combining the subsolution with the removed item. Likewise, merge sort does less work than quicksort when splitting but more work when combining the subsolutions.</p>
<div class="admonition warning">
<p><strong>Note:</strong> You can design different decrease-and-conquer or divide-and-conquer algorithms by making different phases of the approach simpler.</p>
</div>
<section id="Algorithm">
<h2><span class="section-number">14.6.1. </span>Algorithm<a class="headerlink" href="#Algorithm" title="Link to this heading"></a></h2>
<p>Quicksort starts by choosing one item as the <strong>pivot</strong>, then splits the other items into those smaller and those larger than the pivot. After each partition is sorted, they’re put together: first the smaller items, then the pivot and finally the larger items.</p>
<p>Here’s how quicksort processes our example, with the pivot being the first item:</p>
<p id="fig-14.6.1"></p><p><a class="reference internal" href="../33_Figures/Figures_14_6.html#Figure-14.6.1"><span class="std std-ref">Figure 14.6.1</span></a></p>
<img alt="Image 14_6_quicksort.png" src="../_images/14_6_quicksort.png" />
<p>In the first step, the pivot is S, the letters that come before S are ORING and the only letter that comes after is T. After sorting ORING into GINOR, the S and T are concatenated back in that order, resulting in GINORST.</p>
<p>Here’s a recursive quicksort algorithm. It uses an auxiliary function that partitions the unsorted sequence into three sequences: the smaller items, a sequence of length 1 with the pivot and the sequence of larger items.</p>
<ol class="arabic simple">
<li><p>if <em>n</em> &lt; 2:</p>
<ol class="arabic simple">
<li><p>let <em>sorted</em> be <em>unsorted</em></p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let (<em>smaller</em>, <em>pivot</em>, <em>larger</em>) be partition(<em>unsorted</em>)</p></li>
<li><p>let <em>sorted</em> be quicksort(<em>smaller</em>, <em>key</em>) concatenated with <em>pivot</em> and quicksort(<em>larger</em>, <em>key</em>)</p></li>
</ol>
</li>
</ol>
<p>Step 2.1 is an abuse of the assignment notation to make the algorithm more readable.</p>
<p>The partition function simply chooses the first item as the pivot and adds the other items to either partition, depending on how they compare to the pivot.</p>
<ol class="arabic simple">
<li><p>let <em>smaller</em> be ()</p></li>
<li><p>let <em>larger</em> be ()</p></li>
<li><p>let <em>pivot</em> be <em>unsorted</em>[0]</p></li>
<li><p>for each <em>index</em> from 1 to <em>n</em> − 1:</p>
<ol class="arabic simple">
<li><p>let <em>item</em> be <em>unsorted</em>[<em>index</em>]</p></li>
<li><p>if <em>key</em>(<em>item</em>) &lt; <em>key</em>(<em>pivot</em>):</p>
<ol class="arabic simple">
<li><p>append <em>item</em> to <em>smaller</em></p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>append <em>item</em> to <em>larger</em></p></li>
</ol>
</li>
</ol>
</li>
<li><p>let <em>output</em> be (<em>smaller</em>, (<em>pivot</em>), <em>larger</em>)</p></li>
</ol>
<p>Note that the final step doesn’t return the pivot but a sequence with it, so that the concatenation operation can be applied in step 2.2 of quicksort.</p>
</section>
<section id="Complexity">
<h2><span class="section-number">14.6.2. </span>Complexity<a class="headerlink" href="#Complexity" title="Link to this heading"></a></h2>
<p>Each recursive call goes through its input sequence twice: first to partition it and then to concatenate the partitions and the pivot. The recursive complexity definition is:</p>
<ul class="simple">
<li><p>if <em>n</em> &lt; 2: T(<em>n</em>) = Θ(1)</p></li>
<li><p>if <em>n</em> ≥ 2: T(<em>n</em>) = Θ(<em>n</em>) + T(│<em>smaller</em>│) + T(│<em>larger</em>│) + Θ(<em>n</em>) = T(│<em>smaller</em>│) + T(│<em>larger</em>│) + Θ(<em>n</em>).</p></li>
</ul>
<p>If the input is sorted, then the pivot (the first item) is the smallest one. So all other items are put in partition <em>larger</em> and partition <em>smaller</em> is empty. The recurrence relation becomes:</p>
<p>T(<em>n</em>) = T(0) + T(<em>n</em> − 1) + Θ(<em>n</em>) = Θ(1) + T(<em>n</em> − 1) + Θ(<em>n</em>) = T(<em>n</em> − 1) + Θ(<em>n</em>).</p>
<p>We’ve seen before that this resolves to T(<em>n</em>) = Θ(<em>n</em>²).</p>
<p>In the best-case scenario, the pivot is the middle value and quicksort halves the sequence, like merge sort. The recurrence becomes:</p>
<p>T(<em>n</em>) = T(<em>n</em> / 2) + T(<em>n</em> / 2) + Θ(<em>n</em>) = 2×T(<em>n</em> / 2) + Θ(<em>n</em>).</p>
<p>This resolves to T(<em>n</em>) = Θ(<em>n</em> log <em>n</em>).</p>
<p>It has been proven that the average complexity of quicksort, when items are in random order, is also log-linear.</p>
<section id="Exercise-14.6.1">
<h3>Exercise 14.6.1<a class="headerlink" href="#Exercise-14.6.1" title="Link to this heading"></a></h3>
<p>What’s the complexity of quicksort if the input is in reverse order?</p>
<p><a class="reference internal" href="../31_Hints/Hints_14_6_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_14_6_01.html"><span class="doc">Answer</span></a></p>
<p>As the analysis shows, the choice of pivot is crucial to achieve log-linear complexity. One common approach is to choose a random item. Another way is to pick the median of the first, middle and last items. Unless we’re unlucky and those three items have duplicate keys, this guarantees the pivot has neither the lowest nor the highest key in the sequence, which would lead to quadratic complexity.</p>
</section>
</section>
<section id="Code-and-performance">
<h2><span class="section-number">14.6.3. </span>Code and performance<a class="headerlink" href="#Code-and-performance" title="Link to this heading"></a></h2>
<p>The code mainly follows the algorithm with two small changes. First, the pivot’s key is computed only once. Second, the partitioning algorithm isn’t in a separate function. This makes the code shorter and easier to follow, in my opinion.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">test</span>

<span class="o">%</span><span class="k">run</span> -i ../m269_sorting


<span class="k">def</span><span class="w"> </span><span class="nf">quick_sorted</span><span class="p">(</span><span class="n">unsorted</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="n">Callable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a permutation with keys in non-decreasing order.</span>

<span class="sd">    Preconditions: for any indices i and j,</span>
<span class="sd">    key(unsorted[i]) and key(unsorted[j]) are comparable</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># base case: sequences with 0 or 1 items are sorted</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unsorted</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">unsorted</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># divide the input: select the pivot and create the partitions</span>
        <span class="n">smaller</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">larger</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pivot</span> <span class="o">=</span> <span class="n">unsorted</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">pivot_key</span> <span class="o">=</span> <span class="n">key</span><span class="p">(</span><span class="n">pivot</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">unsorted</span><span class="p">)):</span>
            <span class="n">item</span> <span class="o">=</span> <span class="n">unsorted</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">pivot_key</span><span class="p">:</span>
                <span class="n">smaller</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">larger</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="c1"># recur into the partitions and combine the results</span>
        <span class="k">return</span> <span class="n">quick_sorted</span><span class="p">(</span><span class="n">smaller</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="n">pivot</span><span class="p">]</span> <span class="o">+</span> <span class="n">quick_sorted</span><span class="p">(</span><span class="n">larger</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>


<span class="n">test</span><span class="p">(</span><span class="n">quick_sorted</span><span class="p">,</span> <span class="n">sorting_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Testing quick_sorted...
Tests finished: 7 passed (100%), 0 failed.
</pre></div></div>
</div>
<p>Let’s confirm that sorting an ascending sequence takes quadratic time:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">doubling</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">doubling</span><span class="p">))</span>
    <span class="o">%</span><span class="k">timeit</span> -r 5 quick_sorted(items, identity)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
256 μs ± 865 ns per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
951 μs ± 2.99 μs per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
3.71 ms ± 2.53 μs per loop (mean ± std. dev. of 5 runs, 100 loops each)
15.2 ms ± 8.48 μs per loop (mean ± std. dev. of 5 runs, 100 loops each)
61.9 ms ± 30 μs per loop (mean ± std. dev. of 5 runs, 10 loops each)
</pre></div></div>
</div>
<p>To observe the log-linear complexity, I use a Python function to shuffle the items to put them in random order:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">random</span><span class="w"> </span><span class="kn">import</span> <span class="n">shuffle</span>

<span class="k">for</span> <span class="n">doubling</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
    <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">2</span><span class="o">**</span><span class="n">doubling</span><span class="p">))</span>
    <span class="n">shuffle</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="o">%</span><span class="k">timeit</span> -r 5 quick_sorted(items, identity)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
47.8 μs ± 109 ns per loop (mean ± std. dev. of 5 runs, 10,000 loops each)
111 μs ± 114 ns per loop (mean ± std. dev. of 5 runs, 10,000 loops each)
253 μs ± 646 ns per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
588 μs ± 2.28 μs per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
1.24 ms ± 996 ns per loop (mean ± std. dev. of 5 runs, 1,000 loops each)
</pre></div></div>
</div>
</section>
<section id="In-place-version">
<h2><span class="section-number">14.6.4. </span>In-place version<a class="headerlink" href="#In-place-version" title="Link to this heading"></a></h2>
<p>Quicksort is usually implemented in-place, swapping smaller and larger items so that the smaller items end up in the left-hand part of the sequence and the larger items in the right-hand part, with the pivot between them. Once each part is sorted, no concatenation is necessary. A visualisation explaining the in-place algorithm is <a class="reference external" href="https://learn2.open.ac.uk/mod/oucontent/view.php?id=2554725&amp;extra=thumbnail_idm38">here</a>.</p>
<p>In-place quicksort uses less memory and is much faster than the version above because it doesn’t create and concatenate sequences. It nevertheless has the same best-, average- and worst-case complexities.</p>
<div class="admonition note">
<p><strong>Info:</strong> Many programming languages used some variant of quicksort before Timsort was invented.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="14_5_merge_sort.html" class="btn btn-neutral float-left" title="14.5. Merge sort" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="14_7_quicksort_variants.html" class="btn btn-neutral float-right" title="14.7. Quicksort variants" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>