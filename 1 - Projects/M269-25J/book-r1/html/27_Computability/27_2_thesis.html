

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>27.2. The Church–Turing thesis</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="27.3. Static analysis" href="27_3_static_analysis.html" />
    <link rel="prev" title="27.1. Turing machine" href="27_1_turing_machine.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="27-introduction.html">27. Computability</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="27_1_turing_machine.html">27.1. Turing machine</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">27.2. The Church–Turing thesis</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Computational-models">27.2.1. Computational models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Universal-models">27.2.2. Universal models</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Length-of-string">27.2.3. Length of string</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-27.2.1">Exercise 27.2.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-27.2.2">Exercise 27.2.2</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="27_3_static_analysis.html">27.3. Static analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="27_4_undecidability.html">27.4. Undecidability</a></li>
<li class="toctree-l2"><a class="reference internal" href="27_5_summary.html">27.5. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="27-introduction.html"><span class="section-number">27. </span>Computability</a></li>
      <li class="breadcrumb-item active"><span class="section-number">27.2. </span>The Church–Turing thesis</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="The-Church–Turing-thesis">
<h1><span class="section-number">27.2. </span>The Church–Turing thesis<a class="headerlink" href="#The-Church–Turing-thesis" title="Link to this heading"></a></h1>
<p>In this section, I discuss the importance of Turing machines.</p>
<section id="Computational-models">
<h2><span class="section-number">27.2.1. </span>Computational models<a class="headerlink" href="#Computational-models" title="Link to this heading"></a></h2>
<p>While a programming language like Python eases the implementation of algorithms, it’s not a good medium to define what algorithm and complexity mean. A programming language simply has too many constructs, making definitions more complicated. For example, we had to define ‘input size’ for each data type: for integers, it’s the number of digits; for sequences and sets, it’s the number of elements; for graphs, it’s the number of nodes and edges. We also had to make assumptions about the complexity
of each operation, like numeric operations on 64-bit numbers taking constant time, in order to analyse the complexity of an algorithm.</p>
<p>In contrast, a Turing machine is so simple that it became the main computational model, on which all concepts are based. A Turing machine defines precisely the concepts of input, output, algorithm (the transition table) and executing an algorithm (what a computational step is and when to stop). This in turn allows derived concepts to also be precisely defined:</p>
<ul class="simple">
<li><p>An algorithm is correct, i.e. solves a given problem, if it stops, for every input that satisfies the preconditions, with an output that satisfies the postconditions.</p></li>
<li><p>A problem is <strong>computable</strong> if there’s an algorithm that solves it.</p></li>
<li><p>The size of the input is the number of symbols until the start of the infinite sequence of blanks.</p></li>
<li><p>The run-time of an algorithm on a given input is the number of steps executed until it stops.</p></li>
<li><p>The complexity of an algorithm is the growth rate of the number of steps in terms of the number of input symbols.</p></li>
</ul>
<p>In summary, the formal definition of algorithm is what can be written as a transition table for a Turing machine, and all other definitions (computability, complexity, classes P and NP, etc.) are based on it.</p>
<div class="admonition warning">
<p><strong>Note:</strong> Turing machines are a formal model of computation: they enable a precise definition of algorithm, complexity and computability.</p>
</div>
<p>You may be wondering if basing the notion of computation on such simple conceptual devices is too restrictive. Is the Turing machine a good model of what modern computers do? Can they compute things the Turing machine can’t?</p>
</section>
<section id="Universal-models">
<h2><span class="section-number">27.2.2. </span>Universal models<a class="headerlink" href="#Universal-models" title="Link to this heading"></a></h2>
<p>In the 1936 paper where Turing introduces his conceptual machine, he provides an argument (not a proof!) for why such a machine can mimic what computers can do. In those days, before electronic computers existed, the word ‘computer’ still meant ‘a human who does mathematical calculations’.</p>
<p>Turing’s argument was in essence as follows. When solving a mathematical problem, humans read and write symbols on sheets of paper and they have a mental state of what to do next. For example, when adding two numbers, they look at each digit, mentally carrying over if necessary, and write the result one digit at a time. Humans can only process a finite number of symbols and can only remember a finite number of things. They can use more sheets of paper as necessary. While the two-dimensional
nature of paper sheets is convenient to put symbols above or under each other, it’s not really essential to the computation itself. For example, the addition of two numbers can also be carried out horizontally.</p>
<p>Therefore, a machine that has an infinite tape, a head that moves back and forth to read and write symbols, and a finite number of states, should be able to compute anything a human (and, nowadays, electronic computers) can. This is known as the <strong>Church–Turing thesis</strong>: anything that can be computed, can be computed by a Turing machine. The statement is a hypothesis, not a theorem, because it can’t be proven: it states that whatever people would informally agree to call an algorithm can be
written as a transition table for the Turing machine.</p>
<p>Earlier, mathematician Alonzo Church defined the <strong>lambda calculus</strong>, a computational model based on functions. It has been proven that the lambda calculus and Turing machines are equivalent, in the sense that what can be computed with one can be computed with the other. Several variants of Turing machines were also proven to be equivalent. For example, a Turing machine with multiple tapes, each with one head that can move independently of the other heads, can be simulated with a single-tape
machine. No computational model has yet been invented that can solve more problems than Turing machines, and this gives further credibility to the Church–Turing thesis.</p>
<p>A modern computer, with multiple CPU cores, gigabytes of RAM and a large disk, cannot solve any problem the humble Turing machine can’t. Very roughly, the reason is as follows.</p>
<p>Any program (in Python, Java, etc.) is translated to machine code, so that the CPU can execute it. Machine code provides a limited number of simple instructions: increment the value in a register, add the values in two registers, fetch a value from a RAM address and put it in a register, etc. If we store the binary content of each memory (register, cache, RAM, disk) in a separate tape with symbols 0 and 1, then each machine code instruction can be implemented with a transition table that moves
the heads of the affected tapes. The transition tables are quite large: you’ve seen how many entries were needed for a simple problem like checking a string is a valid password. However, the point is that a Turing machine that simulates the execution of CPU instructions <em>can</em> be written.</p>
<div class="admonition note">
<p><strong>Info:</strong> How computers process instructions is explained in TM112 Block 1 Part 3.</p>
</div>
<p>Since multi-tape machines are equivalent in computational power to single-tape machines, it follows that any algorithm written in Python (or any other language) and executed by a modern computer can be written as a transition table and executed by a Turing machine.</p>
<p>If any computable problem can be solved with a Turing machine, it means that it can be solved with a Python function that takes a single input of type <code class="docutils literal notranslate"><span class="pre">list</span></code> and has only two variables: a string with the current state and an integer with the index of the list element currently processed. The reason why two variables suffice to write any algorithm is that we can encode additional variables as states or in the list.</p>
<p>When solving the <a class="reference internal" href="27_1_turing_machine.html#Implementation"><span class="std std-ref">parity bit</span></a> problem, we used additional states. Instead of having two Boolean variables that remember whether a letter or a digit occurred, we represented their four possible values with four states: ‘start’ (no letter or digit seen), ‘letter’, ‘digit’ and ‘both’.</p>
<p>Now let’s see an example of storing the additional variables in the tape rather than as additional states.</p>
</section>
<section id="Length-of-string">
<h2><span class="section-number">27.2.3. </span>Length of string<a class="headerlink" href="#Length-of-string" title="Link to this heading"></a></h2>
<p>The problem to be solved is to compute the length of a string:</p>
<blockquote>
<div><p>Given a tape with zero or more letters ‘a’, add 0s and 1s at the end so that they represent, in reverse binary form, the number of letters. When the machine stops, the head is over the left-most digit. For example, if the input is (‘a’, ‘a’), the output is (0, 1) because the number of letters (namely, two) is 10 in binary. The input should be preserved, i.e. it should not be overwritten by other symbols.</p>
</div></blockquote>
<p>Having the binary digits in reverse order allows us to grow the number to the right as we count letters, without overwriting the string.</p>
<p>To solve this problem, when reading an ‘a’, we must move the head right, increment the binary number and return the head to where it was, so that we can read the next ‘a’ without inadvertently skipping any letters.</p>
<p>We thus need to mark the position of the last ‘a’ counted, so that the head can return to that position. The best way to do that is to introduce a new symbol that marks the position. I will use ‘X’ as the symbol (because X marks the spot), but any symbol different from ‘a’, blank, 0 and 1 will do.</p>
<p>We need two states besides ‘start’. One state is to increment the counter, let’s call it ‘up’; the other is to return to the last ‘a’ read, let’s call it ‘back’.</p>
<p>In the ‘up’ state, the head moves right skipping all letters. If it finds a 0 or blank, it writes 1 (one more letter was read) and starts moving back. If it finds a 1, it writes 0 and moves right, staying in the ‘up’ state to carry over the bit and increment the rest of the binary number.</p>
<p>In the ‘back’ state, the head moves left, skipping all symbols until it reads ‘X’. At that point, the ‘X’ is replaced by ‘a’ (to not change the input), the head moves right and we return to state ‘start’, because we’re now going to repeat the same process to count the next letter.</p>
<p>The next figure shows the configurations, i.e. state, tape and head position, the machine goes through to process input (‘a’, ‘a’). The first and second rows of the diagram show, from left to right, the five configurations to count each ‘a’. The third row shows the final configuration: the machine is again in the ‘start’ state and the head is over a digit. This means all letters were processed and the machine stops.</p>
<p id="fig-27.2.1"></p><p><a class="reference internal" href="../33_Figures/Figures_27_2.html#Figure-27.2.1"><span class="std std-ref">Figure 27.2.1</span></a></p>
<img alt="Image 27_2_length.png" src="../_images/27_2_length.png" />
<p>Here’s the transition table.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_tm

<span class="n">LENGTH_IN</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;a&quot;</span><span class="p">}</span>
<span class="n">LENGTH_OUT</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">}</span>

<span class="n">length</span> <span class="o">=</span> <span class="p">{</span>
    <span class="c1"># (state, symbol):  (symbol, head, state)</span>
    <span class="c1"># if &#39;a&#39;, mark the position and start incrementing counter</span>
    <span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span>     <span class="p">(</span><span class="s1">&#39;X&#39;</span><span class="p">,</span> <span class="n">RIGHT</span><span class="p">,</span> <span class="s1">&#39;up&#39;</span><span class="p">),</span>
    <span class="c1"># if empty string, write 0 and stop</span>
    <span class="p">(</span><span class="s1">&#39;start&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>    <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">STAY</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">),</span>

    <span class="c1"># before incrementing, skip all letters</span>
    <span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span>        <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">RIGHT</span><span class="p">,</span> <span class="s1">&#39;up&#39;</span><span class="p">),</span>
    <span class="c1"># if bit is zero: increment and return to marked position</span>
    <span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>          <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">LEFT</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
    <span class="c1"># if bit is one, carry over: keep incrementing</span>
    <span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>          <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">RIGHT</span><span class="p">,</span> <span class="s1">&#39;up&#39;</span><span class="p">),</span>
    <span class="c1"># end of binary number: increment and go back</span>
    <span class="p">(</span><span class="s1">&#39;up&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>       <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">LEFT</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>

    <span class="c1"># to return to marked position, skip all digits and letters</span>
    <span class="p">(</span><span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>        <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">LEFT</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>        <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">LEFT</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">):</span>      <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">LEFT</span><span class="p">,</span> <span class="s1">&#39;back&#39;</span><span class="p">),</span>
    <span class="c1"># restore marked position to &#39;a&#39;; start again with next letter</span>
    <span class="p">(</span><span class="s1">&#39;back&#39;</span><span class="p">,</span> <span class="s1">&#39;X&#39;</span><span class="p">):</span>      <span class="p">(</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">RIGHT</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">check_tm</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">LENGTH_IN</span><span class="p">,</span> <span class="n">LENGTH_OUT</span><span class="p">)</span>

<span class="n">length_tests</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># case,     input,              debug, output</span>
    <span class="p">(</span><span class="s1">&#39;empty&#39;</span><span class="p">,</span>   <span class="p">[],</span>                 <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;one&#39;</span><span class="p">,</span>     <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">],</span>              <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;two&#39;</span><span class="p">,</span>     <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>         <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
    <span class="p">(</span><span class="s1">&#39;three&#39;</span><span class="p">,</span>   <span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span>    <span class="kc">False</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span>
<span class="p">]</span>

<span class="n">check_tm_tests</span><span class="p">(</span><span class="n">length_tests</span><span class="p">,</span> <span class="n">LENGTH_IN</span><span class="p">,</span> <span class="n">LENGTH_OUT</span><span class="p">)</span>

<span class="n">test_tm</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
OK: the transition table passed the automatic checks
OK: the test table passed the automatic checks.
Tests finished: 4 passed (100%), 0 failed.
</pre></div></div>
</div>
<p>Don’t forget to replace <code class="docutils literal notranslate"><span class="pre">False</span></code> with <code class="docutils literal notranslate"><span class="pre">True</span></code> if you want to see the steps for any of the tests.</p>
<p>In summary, although Turing machines are very constrained, we can write any Python function as a (possibly very complicated) transition table, by representing variables as part of the states or part of the tape’s content.</p>
<section id="Exercise-27.2.1">
<h3>Exercise 27.2.1<a class="headerlink" href="#Exercise-27.2.1" title="Link to this heading"></a></h3>
<p>If the input symbols were all the 26 lowercase and 26 uppercase letters, instead of just ‘a’, what changes would you make to the transition table? For this exercise you don’t have to preserve the input: you can overwrite it with marker symbols.</p>
<p><a class="reference internal" href="../31_Hints/Hints_27_2_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_27_2_01.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-27.2.2">
<h3>Exercise 27.2.2<a class="headerlink" href="#Exercise-27.2.2" title="Link to this heading"></a></h3>
<p>Do again the previous exercise, but this time preserving the input.</p>
<p><a class="reference internal" href="../31_Hints/Hints_27_2_02.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_27_2_02.html"><span class="doc">Answer</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="27_1_turing_machine.html" class="btn btn-neutral float-left" title="27.1. Turing machine" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="27_3_static_analysis.html" class="btn btn-neutral float-right" title="27.3. Static analysis" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>