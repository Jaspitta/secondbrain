

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>17.7. Traversing a graph</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="17.8. Breadth- and depth-first search" href="17_8_bfs_dfs.html" />
    <link rel="prev" title="17.6. Classes for graphs" href="17_6_classes.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="17-introduction.html">17. Graphs 1</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="17_1_modelling.html">17.1. Modelling with graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_2_concepts.html">17.2. Basic concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_3_edge_list.html">17.3. Edge list representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_4_adj_matrix.html">17.4. Adjacency matrix representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_5_adj_list.html">17.5. Adjacency list representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_6_classes.html">17.6. Classes for graphs</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">17.7. Traversing a graph</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#First-algorithm">17.7.1. First algorithm</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Complexity">17.7.2. Complexity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Code-and-tests">17.7.3. Code and tests</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-17.7.1">Exercise 17.7.1</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Second-algorithm">17.7.4. Second algorithm</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-17.7.2">Exercise 17.7.2</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="17_8_bfs_dfs.html">17.8. Breadth- and depth-first search</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_9_summary.html">17.9. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="17-introduction.html"><span class="section-number">17. </span>Graphs 1</a></li>
      <li class="breadcrumb-item active"><span class="section-number">17.7. </span>Traversing a graph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Traversing-a-graph">
<h1><span class="section-number">17.7. </span>Traversing a graph<a class="headerlink" href="#Traversing-a-graph" title="Link to this heading"></a></h1>
<p>Several algorithms on rooted trees, e.g. to compute a tree’s height or to evaluate an infix expression represented as a tree, are based on <a class="reference internal" href="../16_Trees/16_3_traversals.html#Traversals"><span class="std std-ref">traversing the tree</span></a>, either in breadth or in depth. Likewise, several graph algorithms are based on traversing the graph, visiting each node once. A graph has no designated root node, so a traversal algorithm takes as input the graph and a start node.</p>
<section id="First-algorithm">
<h2><span class="section-number">17.7.1. </span>First algorithm<a class="headerlink" href="#First-algorithm" title="Link to this heading"></a></h2>
<p>We can traverse a graph by following the outgoing edges of previously visited nodes in order to visit further nodes. We can only visit those nodes reachable from the start node. In a graph there may be multiple paths from the start node to any other node. To avoid visiting a node twice, we track which nodes we have visited.</p>
<p>We keep two sets of nodes: those already visited and those still unprocessed. Initially, the start node has been visited and its out-neighbours are unprocessed. While there are nodes to be processed, we pick one of them and check if it was already visited. If not, we visit the node and add its out-neighbours to the unprocessed nodes.</p>
<p>Here’s the algorithm, with inputs <em>graph</em> and <em>start</em>, which is a node of <em>graph</em>.</p>
<ol class="arabic simple">
<li><p>let <em>visited</em> be {<em>start</em>}</p></li>
<li><p>let <em>unprocessed</em> be the out-neighbours of <em>start</em> in <em>graph</em></p></li>
<li><p>while <em>unprocessed</em> isn’t empty:</p>
<ol class="arabic simple">
<li><p>remove one <em>node</em> from <em>unprocessed</em></p></li>
<li><p>if <em>node</em> not in <em>visited</em>:</p>
<ol class="arabic simple">
<li><p>visit <em>node</em></p></li>
<li><p>add <em>node</em> to <em>visited</em></p></li>
<li><p>for each <em>neighbour</em> in out-neighbours of <em>node</em> in <em>graph</em>:</p>
<ol class="arabic simple">
<li><p>add <em>neighbour</em> to <em>unprocessed</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>What we do when visiting a node (step 3.2.1) depends on the problem at hand.</p>
<p>Step 3.2 ensures two things: each node is visited at most once and only the out-neighbours of unvisited nodes are marked for processing later. Eventually the traversal has visited all nodes it can reach from the start node. From then on, the loop keeps processing nodes, but they’ve all been visited and so no further nodes are added for processing. At some point, the set of unprocessed nodes becomes empty and the algorithm stops.</p>
</section>
<section id="Complexity">
<h2><span class="section-number">17.7.2. </span>Complexity<a class="headerlink" href="#Complexity" title="Link to this heading"></a></h2>
<p>Let’s analyse the complexity of the traversal itself, ignoring step 3.2.1.</p>
<p>What’s a best-case scenario and the corresponding complexity?</p>
<hr class="docutils" />
<p>The algorithm does the least work if it only visits the start node and doesn’t enter the loop, i.e. <em>unprocessed</em> is empty. This happens if the start node has no neighbours. In such a best-case scenario, steps 1 and 2 take constant time.</p>
<p>The algorithm does the most work when all nodes are reachable from the start node. In a worst-case scenario, it visits all <em>n</em> nodes.</p>
<p>It’s sometimes easier to analyse an algorithm if we look at the overall complexity of each non-loop statement, instead of looking at the complexity of a single execution and then multiplying by the number of iterations.</p>
<p>Here’s the algorithm again, annotated with the total worst-case complexity of each step, except for loops and for visiting nodes.</p>
<ol class="arabic simple">
<li><p>Θ(1) let <em>visited</em> be {<em>start</em>}</p></li>
<li><p>Θ(out-degree(<em>start</em>)) let <em>unprocessed</em> be the out-neighbours of <em>start</em> in <em>graph</em></p></li>
<li><p>while <em>unprocessed</em> isn’t empty:</p>
<ol class="arabic simple">
<li><p>Θ(<em>e</em>) remove one <em>node</em> from <em>unprocessed</em></p></li>
<li><p>Θ(<em>e</em>) if <em>node</em> not in <em>visited</em>:</p>
<ol class="arabic simple">
<li><p>visit <em>node</em></p></li>
<li><p>Θ(<em>n</em>) add <em>node</em> to <em>visited</em></p></li>
<li><p>for each <em>neighbour</em> in out-neighbours of <em>node</em> in <em>graph</em>:</p>
<ol class="arabic simple">
<li><p>Θ(<em>e</em>) add <em>neighbour</em> to <em>unprocessed</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>The initialisation assignments are done only once.</p>
<p>Because of step 3.2, each node is visited once, so step 3.2.2 is executed <em>n</em> times in total.</p>
<p>Step 3.2.3 goes through every out-neighbour of each visited node and all nodes are visited in a worst-case scenario, so the algorithm goes through all edges. In other words, every edge is added to set <em>unprocessed</em> in step 3.2.3.1 and later removed in step 3.1. The while-loop is executed <em>e</em> times and so is step 3.2.</p>
<p>All operations on sets take constant time, so the worst-case complexity is</p>
<p>Θ(1) + Θ(out-degree(<em>start</em>)) + Θ(<em>n</em>) + 3×Θ(<em>e</em>) = Θ(<em>n</em> + <em>e</em>).</p>
<p>As usual, we ignore constant factors and the faster operations: the out-degree of <em>start</em> is never more than the total number of edges, so Θ(out-degree(<em>start</em>)) + Θ(<em>n</em>) = Θ(<em>n</em>).</p>
<p>Most graphs have more edges than nodes, so Θ(<em>n</em> + <em>e</em>) = Θ(<em>e</em>) for them. But some graphs have more nodes than edges, so Θ(<em>n</em> + <em>e</em>) = Θ(<em>n</em>) for them. We could therefore say that the worst-case complexity of traversing a graph is Θ(<em>n</em>) if it has more nodes than edges, otherwise it is Θ(<em>e</em>).</p>
<p>The densest graphs have <em>n</em> × (<em>n</em> – 1) edges, so Θ(<em>n</em> + <em>e</em>) = Θ(<em>n</em>) + O(<em>n</em>²) = O(<em>n</em>²) for any graph. Once we replace a graph’s exact number of edges <em>e</em> with an upper bound (the maximal number of edges), we must use <a class="reference internal" href="../13_Divide/13_3_variable_decrease.html#Complexity"><span class="std std-ref">Big-Oh</span></a> instead of Big-Theta notation.</p>
<p>In summary, we can give the complexity of graph algorithms in terms of just the number of edges or just the number of nodes, but it’s simpler, more general and more precise to state it in terms of both.</p>
<div class="admonition warning">
<p><strong>Note:</strong> State the complexity of graph algorithms in terms of the number of nodes <em>n</em> and the number of edges <em>e</em>.</p>
</div>
</section>
<section id="Code-and-tests">
<h2><span class="section-number">17.7.3. </span>Code and tests<a class="headerlink" href="#Code-and-tests" title="Link to this heading"></a></h2>
<p>Let’s implement and test the algorithm. I must first load both graph classes and the special graphs.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_digraph
<span class="o">%</span><span class="k">run</span> -i ../m269_ungraph
<span class="o">%</span><span class="k">run</span> -i ../m269_graphs
</pre></div>
</div>
</div>
<p>Instead of a set, I keep the visited nodes in a sequence and return it, to see in which order the nodes were visited.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">traversal</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">DiGraph</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return all nodes reachable from start, in the order visited.</span>

<span class="sd">    Preconditions: graph.has_node(start)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="n">unprocessed</span> <span class="o">=</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unprocessed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">node</span> <span class="o">=</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="n">unprocessed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">neighbour</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">visited</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversal</span><span class="p">(</span><span class="n">null_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>  <span class="c1"># null graph with several nodes</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[0]
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversal</span><span class="p">(</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># start from node 1</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[1, 0, 2, 3]
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversal</span><span class="p">(</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[0, 1, 2, 3]
</pre></div></div>
</div>
<p>As you can check, only the reachable nodes are visited and they’re visited once, even if there are multiple paths from the start node to it.</p>
<section id="Exercise-17.7.1">
<h3>Exercise 17.7.1<a class="headerlink" href="#Exercise-17.7.1" title="Link to this heading"></a></h3>
<p><a class="reference internal" href="../06_Implementing/06_4_bounded.html#Outlining-algorithms"><span class="std std-ref">Outline</span></a> an algorithm that does a traversal to decide if a given non-empty undirected graph is connected.</p>
<p><a class="reference internal" href="../31_Hints/Hints_17_7_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_17_7_01.html"><span class="doc">Answer</span></a></p>
</section>
</section>
<section id="Second-algorithm">
<h2><span class="section-number">17.7.4. </span>Second algorithm<a class="headerlink" href="#Second-algorithm" title="Link to this heading"></a></h2>
<p>In a rooted tree, there’s a single path from the root to each node. A traversal of a rooted tree can simply return a sequence of visited nodes, like the algorithm above, because we know exactly how each node was reached: via the edge from its parent.</p>
<p>But for graphs in general, a node may be reached in several ways, via any of its neighbours. It may be more useful to return the actually traversed <strong>subgraph</strong>, i.e. the subset of nodes visited and edges followed.</p>
<p>The next algorithm is a modification of the first so that we can see how a graph is traversed. Instead of marking out-neighbours to be processed, I mark the outgoing edges. When picking the next edge to process, I add it to the subgraph, which initially has just the start node.</p>
<ol class="arabic simple">
<li><p>let <em>visited</em> be a digraph with node <em>start</em></p></li>
<li><p>let <em>unprocessed</em> be the set of the outgoing edges from <em>start</em></p></li>
<li><p>while <em>unprocessed</em> isn’t empty:</p>
<ol class="arabic simple">
<li><p>remove one edge (<em>previous</em>, <em>current</em>) from <em>unprocessed</em></p></li>
<li><p>if <em>visited</em> doesn’t have node <em>current</em>:</p>
<ol class="arabic simple">
<li><p>visit <em>current</em></p></li>
<li><p>add <em>current</em> to <em>visited</em></p></li>
<li><p>add (<em>previous</em>, <em>current</em>) to <em>visited</em></p></li>
<li><p>for each <em>neighbour</em> in out-neighbours of <em>current</em> in <em>graph</em>:</p>
<ol class="arabic simple">
<li><p>add (<em>current</em>, <em>neighbour</em>) to <em>unprocessed</em></p></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Why does the if-statement not add node <em>previous</em> to graph <em>visited</em>?</p>
<hr class="docutils" />
<p>An edge (A, B) is added to <em>unprocessed</em> by step 2 or by step 3.2.4.1. Either step is preceded by adding A to the graph, in step 1 or step 3.2.2. Hence, when removing (A, B) from <em>unprocessed</em>, i.e. when following the edge from A to B, we only have to add B to the graph.</p>
<p>Changing the type of <em>visited</em> from a set to a digraph doesn’t affect the algorithm’s complexity. Every step on <em>visited</em> (adding a node, checking if it has a node) still takes constant time. Keeping pairs of nodes in <em>unprocessed</em> instead of single nodes doesn’t change the complexity either.</p>
<p>The code is as follows.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">traversed</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">DiGraph</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DiGraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the traversed subgraph when beginning at start.</span>

<span class="sd">    Preconditions: graph.has_node(start)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">unprocessed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="n">unprocessed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">))</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">unprocessed</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">unprocessed</span><span class="o">.</span><span class="n">add</span><span class="p">((</span><span class="n">current</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">visited</span>
</pre></div>
</div>
</div>
<p>Let’s see the traversal in action, including with a random graph.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversed</span><span class="p">(</span><span class="n">null_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># null graph with several nodes</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_7_traversal_25_0.png" src="../_images/17_Graphs_1_17_7_traversal_25_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversed</span><span class="p">(</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># start from node 1</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_7_traversal_26_0.png" src="../_images/17_Graphs_1_17_7_traversal_26_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversed</span><span class="p">(</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_7_traversal_27_0.png" src="../_images/17_Graphs_1_17_7_traversal_27_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random</span> <span class="o">=</span> <span class="n">random_graph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>
<span class="n">random</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_7_traversal_28_0.png" src="../_images/17_Graphs_1_17_7_traversal_28_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversed</span><span class="p">(</span><span class="n">random</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># start from node 3</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_7_traversal_29_0.png" src="../_images/17_Graphs_1_17_7_traversal_29_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">traversed</span><span class="p">(</span><span class="n">random</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># start from node 5</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_7_traversal_30_0.png" src="../_images/17_Graphs_1_17_7_traversal_30_0.png" />
</div>
</div>
<p>The generated digraph has one edge fewer than the number of nodes because for every node, except the start, exactly one of its incoming edges is followed to visit it. By construction, every node is reachable from the start node, so the generated digraph is connected. These two facts mean that there’s a single path from the start node to each other node. Hence there are no cycles: the generated graph is a DAG. If we ignore edge directions, then we obtain a tree, rooted at the start node.</p>
<section id="Exercise-17.7.2">
<h3>Exercise 17.7.2<a class="headerlink" href="#Exercise-17.7.2" title="Link to this heading"></a></h3>
<p>Outline an algorithm that does a traversal to decide if a given non-empty undirected graph is a tree.</p>
<p><a class="reference internal" href="../31_Hints/Hints_17_7_02.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_17_7_02.html"><span class="doc">Answer</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="17_6_classes.html" class="btn btn-neutral float-left" title="17.6. Classes for graphs" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="17_8_bfs_dfs.html" class="btn btn-neutral float-right" title="17.8. Breadth- and depth-first search" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>