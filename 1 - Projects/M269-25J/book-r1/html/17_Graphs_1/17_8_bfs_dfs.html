

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>17.8. Breadth- and depth-first search</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="17.9. Summary" href="17_9_summary.html" />
    <link rel="prev" title="17.7. Traversing a graph" href="17_7_traversal.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="17-introduction.html">17. Graphs 1</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="17_1_modelling.html">17.1. Modelling with graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_2_concepts.html">17.2. Basic concepts</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_3_edge_list.html">17.3. Edge list representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_4_adj_matrix.html">17.4. Adjacency matrix representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_5_adj_list.html">17.5. Adjacency list representation</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_6_classes.html">17.6. Classes for graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="17_7_traversal.html">17.7. Traversing a graph</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">17.8. Breadth- and depth-first search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Breadth-first-search">17.8.1. Breadth-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Depth-first-search">17.8.2. Depth-first search</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Tests">17.8.3. Tests</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Comparison">17.8.4. Comparison</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="17_9_summary.html">17.9. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="17-introduction.html"><span class="section-number">17. </span>Graphs 1</a></li>
      <li class="breadcrumb-item active"><span class="section-number">17.8. </span>Breadth- and depth-first search</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Breadth--and-depth-first-search">
<h1><span class="section-number">17.8. </span>Breadth- and depth-first search<a class="headerlink" href="#Breadth--and-depth-first-search" title="Link to this heading"></a></h1>
<p>We saw two kinds of <a class="reference internal" href="../16_Trees/16_3_traversals.html#Traversals"><span class="std std-ref">traversals for rooted trees</span></a>. A breadth-first search (BFS) proceeds from the root downwards, level by level: it first visits the root, then its children, then their children, and so on. A depth-first search (DFS) goes down each subtree as far as it can before exploring the next one.</p>
<p>We can traverse graphs in similar ways. Since a traversal finds all nodes reachable from a given node, traversals can also be seen as searches.</p>
<p>Let’s first get the usual preamble out of the way.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_digraph
<span class="o">%</span><span class="k">run</span> -i ../m269_ungraph
<span class="o">%</span><span class="k">run</span> -i ../m269_graphs
</pre></div>
</div>
</div>
<section id="Breadth-first-search">
<h2><span class="section-number">17.8.1. </span>Breadth-first search<a class="headerlink" href="#Breadth-first-search" title="Link to this heading"></a></h2>
<p>Our traversal algorithm puts the unprocessed edges in a set and picks one of them to visit the next node. The traversal is a rambling walk that visits nodes in no particular order.</p>
<p>However, a BFS traverses a graph in a very specific order: it visits first the start node, then its out-neighbours, then their out-neighbours, and so on. To ensure this, we simply process the edges in the order they’re found. The collection of unprocessed edges must be a first-in, first-out sequence. The BFS algorithm is our traversal algorithm with a small change: we use a queue of unprocessed edges instead of a set.</p>
<p>Like sets, queues can support the addition and removal of items in constant time, so the complexity remains unchanged.</p>
<p>To write the code, I copy the <code class="docutils literal notranslate"><span class="pre">traversed</span></code> function, import our implementation of queues, and make small changes to the five lines involving the variable <code class="docutils literal notranslate"><span class="pre">unprocessed</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_queue.py
</pre></div>
</div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this code is also in m269_digraph.py</span>


<span class="k">def</span><span class="w"> </span><span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">DiGraph</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DiGraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the subgraph traversed by a breadth-first search.</span>

<span class="sd">    Preconditions: graph.has_node(start)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># changes from traversed function noted in comments</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">unprocessed</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>  <span class="c1"># was set</span>
    <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="n">unprocessed</span><span class="o">.</span><span class="n">enqueue</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">))</span>  <span class="c1"># was add()</span>
    <span class="k">while</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># was len()</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>  <span class="c1"># was pop()</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">unprocessed</span><span class="o">.</span><span class="n">enqueue</span><span class="p">((</span><span class="n">current</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">))</span>  <span class="c1"># was add()</span>
    <span class="k">return</span> <span class="n">visited</span>
</pre></div>
</div>
</div>
</section>
<section id="Depth-first-search">
<h2><span class="section-number">17.8.2. </span>Depth-first search<a class="headerlink" href="#Depth-first-search" title="Link to this heading"></a></h2>
<p>A depth-first search first visits a node A, then one of A’s out-neighbours, let’s call it B, then one of B’s out-neighbours, and so on. To obtain this behaviour, after adding the outgoing edges of a visited node, we must follow one of them. It is simplest to follow the last added edge. The collection of unprocessed edges must be a last-in, first-out sequence. So, by changing the traversal algorithm to use a stack of unprocessed edges instead of a set, we obtain the DFS algorithm.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_stack
</pre></div>
</div>
</div>
<p>Like for sets, adding and removing items from a stack takes constant time, so again the complexity isn’t affected.</p>
<div class="admonition warning">
<p><strong>Note:</strong> A breadth- or depth-first search of a graph has worst-case complexity Θ(<em>n</em> + <em>e</em>).</p>
</div>
<p>The code is the same as for <code class="docutils literal notranslate"><span class="pre">bfs</span></code>, but with <code class="docutils literal notranslate"><span class="pre">unprocessed</span></code> being a stack rather than a queue.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># this code is also in m269_digraph.py</span>


<span class="k">def</span><span class="w"> </span><span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">:</span> <span class="n">DiGraph</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="n">Hashable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DiGraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the subgraph traversed by a depth-first search.</span>

<span class="sd">    Preconditions: graph.has_node(start)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
    <span class="n">visited</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="n">unprocessed</span> <span class="o">=</span> <span class="n">Stack</span><span class="p">()</span>  <span class="c1"># was Queue()</span>
    <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">start</span><span class="p">):</span>
        <span class="n">unprocessed</span><span class="o">.</span><span class="n">push</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">))</span>  <span class="c1"># was enqueue()</span>
    <span class="k">while</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>  <span class="c1"># was dequeue()</span>
        <span class="n">previous</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">visited</span><span class="o">.</span><span class="n">has_node</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">previous</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">unprocessed</span><span class="o">.</span><span class="n">push</span><span class="p">((</span><span class="n">current</span><span class="p">,</span> <span class="n">neighbour</span><span class="p">))</span>  <span class="c1"># was enqueue()</span>
    <span class="k">return</span> <span class="n">visited</span>
</pre></div>
</div>
</div>
</section>
<section id="Tests">
<h2><span class="section-number">17.8.3. </span>Tests<a class="headerlink" href="#Tests" title="Link to this heading"></a></h2>
<p>Let’s compare the subgraphs generated by BFS and DFS when traversing the same input graph from the same start node.</p>
<p>First, a null graph with multiple nodes. BFS and DFS generate the same graph, just with the start node, because there are no edges to follow.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bfs</span><span class="p">(</span><span class="n">null_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># nodes: 0, 1, 2; start node: 0</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_16_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_16_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dfs</span><span class="p">(</span><span class="n">null_graph</span><span class="p">(</span><span class="mi">3</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_17_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_17_0.png" />
</div>
</div>
<p>BFS and DFS also traverse path graphs in the same way, as there’s no choice of which edges to follow.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bfs</span><span class="p">(</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># start node: 1</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_19_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_19_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dfs</span><span class="p">(</span><span class="n">path_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_20_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_20_0.png" />
</div>
</div>
<p>However, for complete graphs, the outputs differ. BFS generates a star-shaped graph because all other nodes are out-neighbours of the start node. DFS generates a directed path graph, because there’s always an edge that can be followed from any current node to any yet-unvisited node.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bfs</span><span class="p">(</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># start node: 2</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_22_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_22_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dfs</span><span class="p">(</span><span class="n">complete_graph</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_23_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_23_0.png" />
</div>
</div>
<p>For random graphs, the BFS and DFS traversals may be different or the same, as you can observe by executing the following cells several times. I set the edge probability to 40% but you can change it. As the probability increases from 0% (null graph) to 100% (complete graph), the BFS and DFS traversals are less likely to be the same: the traversals are always equal for null graphs and always different for complete graphs, no matter the start node.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">random</span> <span class="o">=</span> <span class="n">random_graph</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">)</span>  <span class="c1"># set a lower or higher probability</span>
<span class="n">random</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_25_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_25_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bfs</span><span class="p">(</span><span class="n">random</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># start node: 3</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_26_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_26_0.png" />
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">dfs</span><span class="p">(</span><span class="n">random</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_27_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_27_0.png" />
</div>
</div>
</section>
<section id="Comparison">
<h2><span class="section-number">17.8.4. </span>Comparison<a class="headerlink" href="#Comparison" title="Link to this heading"></a></h2>
<p>Like the basic ‘walk’ traversal, BFS and DFS produce a directed tree of the nodes reachable from the start. The three algorithms traverse an acyclic subgraph of the input graph and thus any of them can be used to decide if the input graph is connected or is a tree.</p>
<div class="admonition warning">
<p><strong>Note:</strong> If a graph problem is about connectivity, you can probably solve it with any traversal algorithm.</p>
</div>
<p>However, the difference between DFS and BFS leads to one advantage of BFS. DFS extends one path as far as it can. When that path leads to no unvisited nodes, it tries a different path. BFS instead extends different paths from the start node one edge at a time, because it first visits the start node’s out-neighbours, then their out-neighbours, and so on. In other words, BFS first finds the nodes one edge away from the start, then those two edges away, etc.</p>
<div class="admonition warning">
<p><strong>Note:</strong> BFS finds the shortest paths from the start node to every other reachable node.</p>
</div>
<p>There may be several BFS and DFS subgraphs for the same graph and start node, but the <code class="docutils literal notranslate"><span class="pre">bfs</span></code> and <code class="docutils literal notranslate"><span class="pre">dfs</span></code> functions only produce one of them. Which one is produced depends on the order in which nodes are stored internally in the sets of neighbours.</p>
<p>For example, a complete graph with <em>n</em> nodes has (<em>n</em> – 1)! DFS subgraphs from each start node. After the start node, DFS can visit any of the <em>n</em> – 1 other nodes, then any of the <em>n</em> – 2 remaining nodes, and so on. The above 4-node complete graph has (4 – 1)! = 6 DFS subgraphs from start node 0: 0 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 1 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 3, 0 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 1 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 3 <span class="math notranslate nohighlight">\(\rightarrow\)</span> 2 and every other directed path graph obtained by permutation of
nodes 1, 2 and 3.</p>
<p>However, there’s a single BFS subgraph for a complete graph and start node: as seen earlier, it’s in the form of a star, with the start node in the centre.</p>
<p>The simplest example of a graph with two BFS subgraphs is the following:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">kite</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
<span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="s2">&quot;ABCD&quot;</span><span class="p">:</span>
    <span class="n">kite</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
<span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;AB&quot;</span><span class="p">,</span> <span class="s2">&quot;AC&quot;</span><span class="p">,</span> <span class="s2">&quot;BD&quot;</span><span class="p">,</span> <span class="s2">&quot;CD&quot;</span><span class="p">):</span>
    <span class="n">kite</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">edge</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edge</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">kite</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_34_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_34_0.png" />
</div>
</div>
<p>There are two subgraphs starting from A, depending on whether D is visited from B or from C, but the function produces only one of them.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">bfs</span><span class="p">(</span><span class="n">kite</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/17_Graphs_1_17_8_bfs_dfs_36_0.png" src="../_images/17_Graphs_1_17_8_bfs_dfs_36_0.png" />
</div>
</div>
<p>If you run the last cell, you may get the other subgraph. To understand why the same code can produce different outputs at different times for the same input, remember that in Python the hash value of a string changes in every interpreter session (see the paragraph before <a class="reference internal" href="../08_Unordered/08_3_hash_table.html#Unhashable-values"><span class="std std-ref">Section 8.3.3</span></a>) and sets are implemented with hash tables. So, the internal order of strings ‘B’ and ‘C’ in the set of A’s neighbours may change between sessions,
leading to a different BFS subgraph.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="17_7_traversal.html" class="btn btn-neutral float-left" title="17.7. Traversing a graph" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="17_9_summary.html" class="btn btn-neutral float-right" title="17.9. Summary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>