

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>26.1. Tractable and intractable problems</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="26.2. The P and NP classes" href="26_2_P_and_NP.html" />
    <link rel="prev" title="26. Complexity classes" href="26-introduction.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="26-introduction.html">26. Complexity classes</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">26.1. Tractable and intractable problems</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Problem-complexity">26.1.1. Problem complexity</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Tractable-problems">26.1.2. Tractable problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Intractable-problems">26.1.3. Intractable problems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#The-twilight-zone">26.1.4. The twilight zone</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-26.1.1">Exercise 26.1.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-26.1.2">Exercise 26.1.2</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-26.1.3">Exercise 26.1.3</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-26.1.4">Exercise 26.1.4</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="26_2_P_and_NP.html">26.2. The P and NP classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_3_reductions.html">26.3. Reductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_4_hardness.html">26.4. Problem hardness</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_5_theory_practice.html">26.5. Theory and Practice</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_6_summary.html">26.6. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="26-introduction.html"><span class="section-number">26. </span>Complexity classes</a></li>
      <li class="breadcrumb-item active"><span class="section-number">26.1. </span>Tractable and intractable problems</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Tractable-and-intractable-problems">
<h1><span class="section-number">26.1. </span>Tractable and intractable problems<a class="headerlink" href="#Tractable-and-intractable-problems" title="Link to this heading"></a></h1>
<p>Before we look at two major classes of problems, we must transfer the notion of complexity from algorithms to problems.</p>
<section id="Problem-complexity">
<h2><span class="section-number">26.1.1. </span>Problem complexity<a class="headerlink" href="#Problem-complexity" title="Link to this heading"></a></h2>
<p>The classification of problems is based on how efficiently they can be solved, so the <strong>complexity of a problem</strong> is defined as the complexity of the most efficient algorithm that solves it. Like for algorithms, we could distinguish between the best-, average- and worst-case complexity of a problem, but for the classification of problems we’re only interested in worst-case scenarios.</p>
<div class="admonition warning">
<p><strong>Note:</strong> In this chapter, we only consider worst-case complexities and I will therefore often omit the ‘ worst-case’ adjective.</p>
</div>
<p>It’s important to realise that the complexity of a problem is the lowest complexity of <em>all</em> algorithms that solve the problem, including those that haven’t been discovered yet. To be able to say that a problem has, say, quadratic complexity, we must construct a quadratic algorithm that solves the problem <em>and</em> we must <em>prove</em> that it’s impossible to write a more efficient algorithm.</p>
<p>Consider the problem of sorting comparable items. This problem has log-linear complexity because there are log-linear algorithms that solve it, like merge sort and heapsort, and there’s <a class="reference internal" href="../14_Sorting/14_8_pigeonhole.html#Comparison-sort-complexity"><span class="std std-ref">a proof</span></a> that a log-linear number of comparisons is needed to sort the items. Hence no algorithm with a lower complexity is possible. (More efficient algorithms, like pigeonhole sort, only work for items that can be sorted without comparing
them.)</p>
<p>For many problems, like the TSP, their exact complexity is unknown because there’s currently no proof that the most efficient algorithm we know of is also the most efficient algorithm there will ever be. In other words, there’s no proof that a more efficient algorithm is impossible.</p>
<p>All we can say for such problems is that their complexity is <em>at most</em> the complexity of the most efficient known algorithm and <em>at least</em> the complexity it takes to produce the output. For example, the complexity of the TSP is at least linear, because it takes linear time to copy all nodes to the output tour, and at most exponential, because the best known algorithm has that complexity. The exact complexity of the TSP could be linear, exponential, or anything in between. We don’t know which one
it is yet.</p>
</section>
<section id="Tractable-problems">
<h2><span class="section-number">26.1.2. </span>Tractable problems<a class="headerlink" href="#Tractable-problems" title="Link to this heading"></a></h2>
<p>A polynomial is an expression of the form <span class="math notranslate nohighlight">\(a_o + a_1×n + a_2×n² + ... + a_c×n^c\)</span>, where the <span class="math notranslate nohighlight">\(a\)</span>’s and the <span class="math notranslate nohighlight">\(c\)</span> are constants and <span class="math notranslate nohighlight">\(n\)</span> is a numeric variable. For example, 5 + 3<em>n</em> + 2.5<em>n</em>² + 0.5<em>n</em>⁴ is a polynomial with <span class="math notranslate nohighlight">\(a_3\)</span> = 0.</p>
<div class="admonition note">
<p><strong>Info:</strong> MST124 Unit 3 Section 1.6 introduces polynomials.</p>
</div>
<p>In complexity analysis, only the highest term counts and constant factors are ignored, so</p>
<div class="math notranslate nohighlight">
\[\mathrm{O}(a_o + a_1×n + a_2×n² + ... + a_c×n^c) = \mathrm{O}(n^c).\]</div>
<p>That’s why we say that an algorithm with complexity O(<span class="math notranslate nohighlight">\(n^c\)</span>) has <strong>polynomial complexity</strong>, or vice versa, that a <strong>polynomial algorithm</strong> has complexity O(<span class="math notranslate nohighlight">\(n^c\)</span>).</p>
<p>Big-Oh indicates an upper bound, so having polynomial complexity means to have complexity Θ(<span class="math notranslate nohighlight">\(n^c\)</span>) or better. Therefore, any algorithm with constant, logarithmic, linear, log-linear, quadratic or cubic complexity is polynomial because it has complexity Θ(<em>n</em>³) or better. Most M269 algorithms have polynomial complexity.</p>
<p>A problem is <strong>tractable</strong> if it has polynomial complexity, i.e. if the most efficient algorithm that solves the problem has complexity Θ(<span class="math notranslate nohighlight">\(n^c\)</span>) or better, for input size <span class="math notranslate nohighlight">\(n\)</span> and some constant <span class="math notranslate nohighlight">\(c\)</span>. Most M269 problems are tractable.</p>
<p>We don’t always need to know the exact complexity of a problem to know if it’s tractable: a single algorithm of polynomial complexity is sufficient. For example, if the only known sorting algorithm were insertion sort, that would be enough to show that the sorting problem is tractable, as follows:</p>
<ol class="arabic simple">
<li><p>Since the most efficient sorting algorithm can’t be worse than insertion sort, it must have complexity Θ(<em>n</em>²) or better.</p></li>
<li><p>Since the most efficient sorting algorithm has complexity Θ(<span class="math notranslate nohighlight">\(n^c\)</span>) or better for <em>c</em> = 2, it has by definition polynomial complexity.</p></li>
<li><p>Since the most efficient sorting algorithm has polynomial complexity, by definition the sorting problem has polynomial complexity.</p></li>
<li><p>Since the sorting problem has polynomial complexity, it is by definition tractable.</p></li>
</ol>
<p>Usually, we don’t spell out all these steps: we simply say that the sorting problem is tractable because it is solved by a polynomial algorithm, e.g. insertion sort, which has quadratic complexity.</p>
<div class="admonition warning">
<p><strong>Note:</strong> To show that a problem is tractable you only need to indicate or construct <em>one</em> polynomial algorithm that solves the problem.</p>
</div>
</section>
<section id="Intractable-problems">
<h2><span class="section-number">26.1.3. </span>Intractable problems<a class="headerlink" href="#Intractable-problems" title="Link to this heading"></a></h2>
<p>A problem is <strong>intractable</strong> if it’s not tractable: there’s no polynomial algorithm for it. The most efficient algorithm for an intractable problem has complexity higher than O(<span class="math notranslate nohighlight">\(n^c\)</span>). There are many such complexities but in M269 you learned only two: the exponential and factorial complexities Θ(2ⁿ) and Θ(<em>n</em>!).</p>
<p>A problem that can be solved with an exponential or factorial algorithm isn’t necessarily intractable: there might be a polynomial algorithm that solves it, making the problem tractable. For example, the sorting problem can be solved with the factorial <a class="reference internal" href="../14_Sorting/14_2_bogosort.html#Bogosort"><span class="std std-ref">bogosort</span></a> algorithm, but the sorting problem is actually tractable, as explained above.</p>
<p>To classify a problem as intractable we must prove that no polynomial algorithm solves it. There’s a case where this can be easily proven, namely if the size of the output is exponential or factorial in the size of the input. In that case, even if each item in the output can be computed in constant time, it will take an exponential or factorial time to produce the output, and therefore no polynomial algorithm for it can exist.</p>
<p>For example, the problem of <a class="reference internal" href="../11_Search/11_5_subsets.html#Code"><span class="std std-ref">computing all subsets</span></a> of a given set with <em>n</em> items is intractable, because there are 2ⁿ subsets. Even if each subset were produced in constant time, it would take exponential time to produce all of them, and so no polynomial algorithm can solve the problem.</p>
<div class="admonition warning">
<p><strong>Note:</strong> If the size of the output is exponential or factorial in the size of the input, then the problem is intractable.</p>
</div>
<p>In Python, floating-point numbers have a fixed size (64 bits), but integers can be arbitrarily large. So be careful when analysing the complexity of problems that have integer inputs, because the complexity is the growth rate of the run-time with respect to the input <em>size</em>, not the input <em>value</em>.</p>
<p>For example, the multiplication of integers <em>x</em> and <em>y</em> takes constant time for 64-bit integers. But for arbitrarily large integers, an algorithm that multiplies each digit of <em>x</em> with each digit of <em>y</em> has complexity Θ(│<em>x</em>│ × │<em>y</em>│), the product of the sizes of both numbers.</p>
<p>The size of an integer <em>n</em> is │<em>n</em>│ = <span class="math notranslate nohighlight">\(\log_2\)</span> <em>n</em> because that’s the least number of bits required to store <em>n</em>. For example, │23│ = <span class="math notranslate nohighlight">\(\log_2\)</span> 23 = 4.52. In fact, 23 is written 10111 in binary, which takes 5 bits, but we’ll ignore the rounding up because it doesn’t affect the complexity.</p>
<p>Since the logarithm and exponentiation are inverse operations, we have <span class="math notranslate nohighlight">\(n = 2^{\log_2 n} = 2^{│n│}\)</span>. So, if we have a complexity expression in terms of the value <span class="math notranslate nohighlight">\(n\)</span>, then the expression in terms of the size │<span class="math notranslate nohighlight">\(n\)</span>│ is obtained by replacing <span class="math notranslate nohighlight">\(n\)</span> with <span class="math notranslate nohighlight">\(2^{│n│}\)</span>, which in turn can be replaced with <span class="math notranslate nohighlight">\(2^{\log n}\)</span> because we <a class="reference internal" href="../13_Divide/13_2_decrease_half.html#Complexity"><span class="std std-ref">ignore the base of logarithms</span></a> when analysing complexity.</p>
<p>For example, our <a class="reference internal" href="../11_Search/11_2_factorisation.html#Sort-candidates"><span class="std std-ref">factorisation algorithm</span></a> for a positive integer <span class="math notranslate nohighlight">\(n\)</span> has complexity <span class="math notranslate nohighlight">\(Θ(\sqrt{n}) = Θ(n^{0.5})\)</span>. This means the factorisation algorithm is polynomial in the input <em>value</em> because the complexity is of the form Θ(<span class="math notranslate nohighlight">\(n^c\)</span>). However, to express the complexity in terms of the input <em>size</em> we must write</p>
<div class="math notranslate nohighlight">
\[Θ(n^{0.5}) = Θ((2^{│n│})^{0.5}) = Θ((2^{\log n})^{0.5})
= Θ(2^{0.5 \log n}) = Θ(2^{\log n}).\]</div>
<p>(Remember that complexity analysis ignores constant factors.) It thus turns out that factorisation is exponential in terms of the input size, which is the log <em>n</em> bits required to represent <em>n</em>.</p>
<div class="admonition note">
<p><strong>Info:</strong> MU123 Unit 3 Section 1.5 explains why <span class="math notranslate nohighlight">\((x^y)^z = x^{y × z}\)</span> and Section 3.4 explains why <span class="math notranslate nohighlight">\(\sqrt{x} = x^{0.5}\)</span>.</p>
</div>
<p>Algorithms that have polynomial complexity in the <em>value</em> (but not in the <em>size</em>) of an integer input are called <strong>pseudo-polynomial</strong>.</p>
<div class="admonition warning">
<p><strong>Note:</strong> A pseudo-polynomial algorithm seems polynomial but is in fact exponential.</p>
</div>
</section>
<section id="The-twilight-zone">
<h2><span class="section-number">26.1.4. </span>The twilight zone<a class="headerlink" href="#The-twilight-zone" title="Link to this heading"></a></h2>
<p>For some problems, we don’t know if they’re tractable or not. This happens when the currently most efficient algorithm is <em>not</em> polynomial but the output’s size <em>is</em> polynomial in the size of the input and so a polynomial algorithm <em>might</em> be possible.</p>
<p>For example, I wrote earlier that the exact complexity of the TSP is at least linear and at most exponential. So the problem could be tractable or intractable.</p>
<ul class="simple">
<li><p>If someone invents a polynomial algorithm for the TSP, then we know it’s tractable.</p></li>
<li><p>If someone proves that there can’t be a polynomial algorithm for the TSP, then we know it’s intractable.</p></li>
</ul>
<div class="admonition warning">
<p><strong>Note:</strong> If a problem’s complexity is at most non-polynomial but could be polynomial, then we don’t know if the problem is tractable or intractable.</p>
</div>
<section id="Exercise-26.1.1">
<h3>Exercise 26.1.1<a class="headerlink" href="#Exercise-26.1.1" title="Link to this heading"></a></h3>
<p>Based only on what you have read in this book, is the <a class="reference internal" href="../18_Greed/18_1_scheduling.html#Interval-scheduling"><span class="std std-ref">interval scheduling</span></a> problem tractable, intractable or can’t you say either way?</p>
<p><a class="reference internal" href="../31_Hints/Hints_26_1_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_26_1_01.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-26.1.2">
<h3>Exercise 26.1.2<a class="headerlink" href="#Exercise-26.1.2" title="Link to this heading"></a></h3>
<p>Based only on what you have read in this book, is the <a class="reference internal" href="../23_Dynamic_Programming/23_3_knapsack.html#Knapsack"><span class="std std-ref">0/1 knapsack</span></a> problem tractable, intractable or can’t you say either way?</p>
<p><a class="reference internal" href="../31_Hints/Hints_26_1_02.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_26_1_02.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-26.1.3">
<h3>Exercise 26.1.3<a class="headerlink" href="#Exercise-26.1.3" title="Link to this heading"></a></h3>
<p>A group of tourists is visiting a city on foot. They start the day in their hotel. They know the restaurants where they will have lunch and dinner. They will visit a museum immediately after lunch.</p>
<p>Given an unweighted, undirected, connected graph representing the city’s places and streets, we want to compute all paths from node <em>Hotel</em> to node <em>Dinner</em> that go through nodes <em>Lunch</em> and <em>Museum</em> one after the other.</p>
<p>Is this problem tractable, intractable or can’t you say?</p>
<p><a class="reference internal" href="../31_Hints/Hints_26_1_03.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_26_1_03.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-26.1.4">
<h3>Exercise 26.1.4<a class="headerlink" href="#Exercise-26.1.4" title="Link to this heading"></a></h3>
<p>Are pseudo-polynomial algorithms intractable? (This may be considered a trick question.)</p>
<p><a class="reference internal" href="../31_Hints/Hints_26_1_04.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_26_1_04.html"><span class="doc">Answer</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="26-introduction.html" class="btn btn-neutral float-left" title="26. Complexity classes" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="26_2_P_and_NP.html" class="btn btn-neutral float-right" title="26.2. The P and NP classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>