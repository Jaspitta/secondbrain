

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>26.5. Theory and Practice</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="26.6. Summary" href="26_6_summary.html" />
    <link rel="prev" title="26.4. Problem hardness" href="26_4_hardness.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="26-introduction.html">26. Complexity classes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="26_1_tractable.html">26.1. Tractable and intractable problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_2_P_and_NP.html">26.2. The P and NP classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_3_reductions.html">26.3. Reductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_4_hardness.html">26.4. Problem hardness</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">26.5. Theory and Practice</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Theory">26.5.1. Theory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Practice">26.5.2. Practice</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="26_6_summary.html">26.6. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="26-introduction.html"><span class="section-number">26. </span>Complexity classes</a></li>
      <li class="breadcrumb-item active"><span class="section-number">26.5. </span>Theory and Practice</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Theory-and-Practice">
<h1><span class="section-number">26.5. </span>Theory and Practice<a class="headerlink" href="#Theory-and-Practice" title="Link to this heading"></a></h1>
<p>I close this chapter with some considerations about the theory and practice of algorithmic complexity.</p>
<section id="Theory">
<h2><span class="section-number">26.5.1. </span>Theory<a class="headerlink" href="#Theory" title="Link to this heading"></a></h2>
<p>Problem reduction is very important in helping to understand the nature of problems. If A reduces to B in polynomial time, then A can’t be harder than B:</p>
<ul class="simple">
<li><p>if B can be solved in polynomial time, so can A, and</p></li>
<li><p>vice versa, if A can’t be solved in polynomial time, neither can B.</p></li>
</ul>
<p>Polynomial-time reductions allow us to make general statements, like all NP-complete problems being equally hard and harder than any other NP problem.</p>
<p>Starting from SAT, computer scientists used polynomial-time reductions to classify hundreds of problems. I haven’t shown any polynomial algorithms for the <a class="reference internal" href="../22_Backtracking/22_5_tsp.html#Back-to-the-TSP"><span class="std std-ref">travelling salesman</span></a>, <a class="reference internal" href="../22_Backtracking/22_7_knapsack.html#Back-to-the-knapsack"><span class="std std-ref">0/1 knapsack</span></a>, <a class="reference internal" href="../11_Search/11_5_subsets.html#Exercise-11.5.1"><span class="std std-ref">maximal independent set</span></a> or <a class="reference internal" href="../11_Search/11_6_practice.html#Subset-sum"><span class="std std-ref">subset sum</span></a> problem for one simple reason: they all have
been proven to be NP-hard.</p>
<p>One of the most fascinating aspects of complexity theory for me is that seemingly similar problems fall into different complexity classes. Here are some examples.</p>
<p>The <strong>fractional knapsack</strong> problem allows us to put a fraction of each item in the knapsack, e.g. when each item is in liquid or powder form. There’s a simple greedy log-linear algorithm that solves this problem: go through the items from most to least profitable (value-to-weight ratio) and take as much as possible from each one until the knapsack is full. This means that the fractional knapsack problem is in P but the 0/1 knapsack problem is NP-hard. If we can put only 0% or 100% of each item
in the knapsack, the problem becomes much harder.</p>
<p>Given a graph, the <strong>all-pairs longest path</strong> problem asks for a non-cyclic path with the most edges (if the graph is unweighted) or with the highest sum of weights (if it’s weighted), among all pairs of nodes. This problem is NP-hard whereas the <strong>all-pairs shortest path</strong> problem is in P because we can use breadth-first search or Dijkstra’s algorithm to solve the <a class="reference internal" href="../18_Greed/18_4_shortest_path.html#Shortest-paths"><span class="std std-ref">single-source shortest paths problem</span></a> for each graph node, and then take
the shortest path of them all.</p>
<p><a class="reference internal" href="../11_Search/11_2_factorisation.html#Exercise-11.2.1"><span class="std std-ref">Exercise 11.2.1</span></a> implicitly showed that the <strong>primality</strong> problem (‘is a given positive integer prime?’) can be reduced in polynomial time to the <strong>factorisation</strong> problem (‘list the positive divisors of a given positive integer’) because a number is prime if and only if it has exactly two factors. There’s an <a class="reference internal" href="../11_Search/11_2_factorisation.html#Sort-candidates"><span class="std std-ref">exponential algorithm</span></a> for the factorisation problem and therefore for
the primality problem. This suggests that both problems are intractable, but we know that reducing A to B isn’t necessarily the most efficient way of solving problem A. In fact, in 2002 three Indian scientists found a polynomial algorithm to check if a number is prime, proving that primality is in P. However, to this day it’s not known whether factorisation is NP-hard, so finding a polynomial algorithm for it won’t prove P = NP.</p>
<p>The <strong>2-SAT</strong> decision problem is a specialised version of SAT in which the input Boolean expression is a conjunction of disjunctions, where each disjunction has exactly two variables or their negations, e.g. ‘(A or B) and (not B or C)’. As you probably guessed, although SAT is NP-complete, 2-SAT is in P. The more specific problem can be solved much more efficiently than by applying exponential brute-force search, as for the general problem. Not all Boolean expressions can be written as a
conjunction of two-variable disjunctions, so the general SAT problem remains important.</p>
</section>
<section id="Practice">
<h2><span class="section-number">26.5.2. </span>Practice<a class="headerlink" href="#Practice" title="Link to this heading"></a></h2>
<p>Reductions also have some practical value: if problem A reduces to problem B then <em>any</em> algorithm that solves B also solves A, via input and output transformations. Usually the obtained algorithm won’t be the most efficient to solve A, but at least it’s a start.</p>
<p>If somebody ever finds <em>one</em> polynomial algorithm for <em>one</em> NP-complete problem, then polynomial algorithms for the hundreds of known NP-complete problems can be immediately implemented, with the polynomial-time reductions used to prove that those problems are NP-complete.</p>
<p>Polynomial algorithms are often characterised as being efficient, because they are being contrasted with the non-polynomial exponential and factorial algorithms. In practice, an exponential algorithm may be efficient enough and a polynomial algorithm may be inefficient, because there are factors at play that are often ignored by the theory, to simplify the analysis.</p>
<p>Complexity analysis and the classification of problems is mostly based on worst-case scenarios, but in real life many inputs aren’t worst cases, so theoretically inefficient algorithms may in practice solve most problem instances in a reasonable time. For example, backtracking can prune the search space effectively for many inputs even though there may be inputs for which all candidates have to be generated.</p>
<p>A further example is SAT solvers: they can routinely handle Boolean expressions with hundreds of variables and thousands of operators. Even though the worst case is exponential, it rarely occurs. In addition, SAT solvers return an interpretation that satisfies the expression, if there is one, i.e. they also return the certificate.</p>
<p>Complexity analysis predicts how the run-time grows for ever-increasing input sizes, but sometimes we’re only interested in small problem instances. In such cases, an inefficient algorithm may be sufficient in practice. For example, supermarket delivery vans typically visit 15–20 customers before returning to the warehouse. A dynamic programming algorithm for the TSP can compute the best tour for graphs with that many nodes in a few seconds.</p>
<p>On the other hand, problems in P may actually have no practical algorithm. A polynomial algorithm with complexity O(<span class="math notranslate nohighlight">\(n^c\)</span>) is inefficient if the exponent <em>c</em> is high or the constant factor (ignored by complexity analysis) is high. What exactly ‘high’ means depends again on the input size. If the input size <em>n</em> is in the thousands, then a cubic algorithm (<em>c</em> = 3) may be very slow.</p>
<p>Another example is the polynomial algorithm to test primality of a number <em>n</em>: it has complexity O(<span class="math notranslate nohighlight">\((\log n)^{12}\)</span>) and is therefore hardly used in practice. Primality testing is required for cryptography, where numbers can have more than 100 digits, i.e. log <em>n</em> &gt; 100, which makes this algorithm impractically slow.</p>
<p>When no exact algorithm is fast enough for large real-world problem instances, practitioners use heuristic algorithms that only provide approximate or probabilistic results. For example, primality is usually decided with an algorithm that gives the right decision with high (but not 100%) probability. And for large graphs, the TSP is solved with algorithms that return an approximate ‘good enough’ result. You have seen a greedy heuristic algorithm for the TSP in <a class="reference internal" href="../18_Greed/18_3_mst.html#Exercise-18.3.1"><span class="std std-ref">Exercise
18.3.1</span></a>.</p>
<p>So if you have an NP-complete or NP-hard problem at hand, first consider what input sizes you will need to cope with. If they are small, an exact exponential algorithm might do the job. Otherwise, look for a heuristic that gives a good approximation of the result or the right result with high probability.</p>
<p>If your problem can be reduced in polynomial time to SAT or the TSP, then implementing the input and output transformations yourself and using a good SAT or TSP solver might be your best bet.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="26_4_hardness.html" class="btn btn-neutral float-left" title="26.4. Problem hardness" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="26_6_summary.html" class="btn btn-neutral float-right" title="26.6. Summary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>