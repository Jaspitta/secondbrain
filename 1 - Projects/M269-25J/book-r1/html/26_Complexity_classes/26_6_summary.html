

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>26.6. Summary</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="27. Computability" href="../27_Computability/27-introduction.html" />
    <link rel="prev" title="26.5. Theory and Practice" href="26_5_theory_practice.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="26-introduction.html">26. Complexity classes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="26_1_tractable.html">26.1. Tractable and intractable problems</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_2_P_and_NP.html">26.2. The P and NP classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_3_reductions.html">26.3. Reductions</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_4_hardness.html">26.4. Problem hardness</a></li>
<li class="toctree-l2"><a class="reference internal" href="26_5_theory_practice.html">26.5. Theory and Practice</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">26.6. Summary</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Reductions">26.6.1. Reductions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Problem-classes">26.6.2. Problem classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Problems">26.6.3. Problems</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="26-introduction.html"><span class="section-number">26. </span>Complexity classes</a></li>
      <li class="breadcrumb-item active"><span class="section-number">26.6. </span>Summary</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Summary">
<h1><span class="section-number">26.6. </span>Summary<a class="headerlink" href="#Summary" title="Link to this heading"></a></h1>
<p>Computer scientists have classified computational problems in many ways, based on the complexity of the algorithms that solve the problems.</p>
<section id="Reductions">
<h2><span class="section-number">26.6.1. </span>Reductions<a class="headerlink" href="#Reductions" title="Link to this heading"></a></h2>
<p>A <strong>polynomial</strong> algorithm has a worst-case complexity of the form O(<span class="math notranslate nohighlight">\(n^c\)</span>), where <em>n</em> is the input size and <em>c</em> is a constant. For example, algorithms with complexity O(<em>n</em>³), i.e. that run in cubic time or less, are polynomial, whereas algorithms with exponential or factorial complexity aren’t.</p>
<p>The <strong>complexity of a problem</strong> is the lowest worst-case complexity of all algorithms that solve the problem. To know a problem’s complexity we must have an algorithm of that complexity and a proof that no other more efficient algorithm solves the problem.</p>
<p>Problem A <strong>reduces</strong> to problem B if there’s an algorithm of the following form that solves A.</p>
<ol class="arabic simple">
<li><p>Transform the inputs of A into the inputs of B.</p></li>
<li><p>Use any algorithm for B.</p></li>
<li><p>Transform the obtained output for B into A’s output.</p></li>
</ol>
<p>Problem A is <strong>at most as hard as</strong> problem B, and B is <strong>at least as hard as</strong> A, if A reduces to B in polynomial time, i.e. if steps 1 and 3 take polynomial time.</p>
<p>A polynomial-time reduction of problem A to problem B can be used for three purposes:</p>
<ul class="simple">
<li><p>Obtain a (possibly inefficient) algorithm for unsolved problem A, given an algorithm for solved problem B.</p></li>
<li><p>Prove that A is tractable, if we know that B is.</p></li>
<li><p>Prove that B is NP-hard, if we know that A is.</p></li>
</ul>
</section>
<section id="Problem-classes">
<h2><span class="section-number">26.6.2. </span>Problem classes<a class="headerlink" href="#Problem-classes" title="Link to this heading"></a></h2>
<p>The classes (sets) of problems covered in M269 are the following. (The first two are based on the output type: they aren’t complexity classes.)</p>
<ul class="simple">
<li><p>Decision problems: those that have as output a Boolean value.</p></li>
<li><p>Non-decision problems: all other problems.</p></li>
<li><p><strong>Tractable</strong> problems: those that can be solved by a polynomial algorithm.</p></li>
<li><p><strong>Intractable</strong> problems: those that can only be solved by non-polynomial algorithms.</p></li>
<li><p>Class <strong>P</strong>: the tractable decision problems, i.e. those that can be solved in polynomial time.</p></li>
<li><p>Class <strong>NP</strong>: the decision problems that can be verified in polynomial time.</p></li>
<li><p>Class <strong>NP-hard</strong>: the problems that are at least as hard as every NP problem.</p></li>
<li><p>Class <strong>NP-complete</strong>: the NP problems that are NP-hard.</p></li>
</ul>
<p>A problem is in NP if there’s a polynomial <strong>verifier</strong> algorithm that, for each input that leads to a true output (a ‘yes’ decision), takes the input and a <strong>certificate</strong>, and confirms that the decision is ‘yes’.</p>
<p>From the definitions it follows that:</p>
<ul class="simple">
<li><p>any NP problem reduces in polynomial time to any NP-hard problem</p></li>
<li><p>all NP-complete problems reduce in polynomial time to each other</p></li>
<li><p>all problems in P are also in NP: P <span class="math notranslate nohighlight">\(\subseteq\)</span> NP.</p></li>
</ul>
<p>It’s unknown if P <span class="math notranslate nohighlight">\(\subset\)</span> NP or P = NP: this is the <strong>P versus NP problem</strong> or <strong>‘P = NP?’ question</strong>.</p>
<p>The relationships between the classes are as follows, for P = NP and for P ≠ NP:</p>
<p id="fig-26.6.1"></p><p><a class="reference internal" href="../33_Figures/Figures_26_6.html#Figure-26.6.1"><span class="std std-ref">Figure 26.6.1</span></a></p>
<img alt="Image 26_4_p_vs_np.png" src="../_images/26_4_p_vs_np.png" />
<p>In practice, a tractable problem may have no usable polynomial algorithm and an NP-complete or NP-hard problem may have a usable exponential algorithm; usability depends on the exponent of the complexity, the hidden constant factors and the real-world problem instances to be dealt with (their sizes and whether they are worst cases). For example, there’s a polynomial algorithm to check if an integer is prime, but due to its large exponent (<em>c</em> = 12), it’s not used in practice.</p>
<p>Heuristic algorithms are often used to handle large instances of NP-complete and NP-hard problems. They compute approximate answers or the correct answer with high probability.</p>
</section>
<section id="Problems">
<h2><span class="section-number">26.6.3. </span>Problems<a class="headerlink" href="#Problems" title="Link to this heading"></a></h2>
<p>The <strong>satisfiability problem</strong> (<strong>SAT</strong>) is:</p>
<div class="line-block">
<div class="line"><strong>Function:</strong> SAT</div>
<div class="line"><strong>Inputs</strong>: <em>expression</em>, a string</div>
<div class="line"><strong>Preconditions:</strong> the string represents a Boolean expression with only variables and logical operators</div>
<div class="line"><strong>Output:</strong> <em>satisfiable</em>, a Boolean</div>
<div class="line"><strong>Postconditions:</strong> <em>satisfiable</em> is true if and only if there are values for the Boolean variables that make <em>expression</em> true</div>
</div>
<p>The postcondition could be rephrased as ‘… if there’s an interpretation that satisfies <em>expression</em>’. An <strong>interpretation</strong> is an assignment of a Boolean value to each variable in the expression.</p>
<p>The <strong>2-SAT</strong> problem is like SAT, but the Boolean expression is a conjunction of disjunctions, with two variables or their negation per disjunction.</p>
<p>The <strong>decision TSP</strong> takes as input a complete weighted graph and a positive integer <em>w</em>. The Boolean output is true if and only if the graph has a tour with total weight <em>w</em> or less.</p>
<p>The <strong>fractional knapsack</strong> problem is like the 0/1 knapsack problem, but the solution can involve taking only part of each item. The output is therefore not just the subset of items put in the knapsack but also the percentage of each item.</p>
<p>The <strong>all-pairs shortest</strong> (or <strong>longest</strong>) <strong>path</strong> problem asks for a shortest (or longest non-cyclic) path in a graph, between any two nodes. If the graph is unweighted, the path has the fewest (or most) edges; if the graph is weighted, the path has the lowest (or highest) sum of weights.</p>
<p>Seemingly similar problems can be in different complexity classes:</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Class</p></th>
<th class="head"><p>Problems</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>NP-hard</p></td>
<td><p>(decision) <a class="reference internal" href="../22_Backtracking/22_5_tsp.html#Back-to-the-TSP"><span class="std std-ref">TSP</span></a>, <a class="reference internal" href="../22_Backtracking/22_7_knapsack.html#Back-to-the-knapsack"><span class="std std-ref">0/1 knapsack</span></a>, <a class="reference internal" href="../11_Search/11_6_practice.html#Subset-sum"><span class="std std-ref">subset sum</span></a>, <a class="reference internal" href="../11_Search/11_5_subsets.html#Exercise-11.5.1"><span class="std std-ref">maximal independent
set</span></a>, all-pairs longest path, SAT</p></td>
</tr>
<tr class="row-odd"><td><p>NP-complete</p></td>
<td><p>SAT, decision TSP</p></td>
</tr>
<tr class="row-even"><td><p>tractable</p></td>
<td><p>all-pairs shortest path, fractional knapsack, 2-SAT, <a class="reference internal" href="../11_Search/11_2_factorisation.html#Prime-numbers"><span class="std std-ref">primality</span></a></p></td>
</tr>
<tr class="row-odd"><td><p>P</p></td>
<td><p>2-SAT, primality</p></td>
</tr>
</tbody>
</table>
<p>Most problems presented in M269 are tractable.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="26_5_theory_practice.html" class="btn btn-neutral float-left" title="26.5. Theory and Practice" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../27_Computability/27-introduction.html" class="btn btn-neutral float-right" title="27. Computability" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>