

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>25.3. Dynamic programming</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="26. Complexity classes" href="../26_Complexity_classes/26-introduction.html" />
    <link rel="prev" title="25.2. Backtracking" href="25_2_backtracking.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="25-introduction.html">25. TMA 03 part 1</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="25_1_graphs.html">25.1. Problems on graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="25_2_backtracking.html">25.2. Backtracking</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">25.3. Dynamic programming</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="25-introduction.html"><span class="section-number">25. </span>TMA 03 part 1</a></li>
      <li class="breadcrumb-item active"><span class="section-number">25.3. </span>Dynamic programming</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Dynamic-programming">
<h1><span class="section-number">25.3. </span>Dynamic programming<a class="headerlink" href="#Dynamic-programming" title="Link to this heading"></a></h1>
<p>Dynamic programming is often applied to optimisation problems on sequences, because sequences are usually easy to process item by item to build up the problem’s solution from the subproblems’ solutions.</p>
<p>To obtain a dynamic programming algorithm, follow these steps.</p>
<ol class="arabic simple">
<li><p><strong>Define the problem recursively.</strong></p></li>
</ol>
<p>This is the key step and usually the hardest one.</p>
<p>The recursive definition has the same usual form. First define the base cases, which include the smallest inputs but possibly other cases too. Then define the recurrence relations: how the solution for a problem instance is obtained from solutions for subproblems (smaller input instances). For problems on sequences, use the head, tail and concatenation operations.</p>
<p>For optimisation problems, the recurrence relation must involve taking the best (typically the maximum or minimum) of two or more subproblem solutions. In the <a class="reference internal" href="../23_Dynamic_Programming/23_2_lcs.html#Recursive"><span class="std std-ref">LCS problem</span></a>, if the two string heads differ, we take the longest of two subsequences, by skipping the left or the right head.</p>
<ol class="arabic simple">
<li><p><strong>Implement the recursive definition.</strong></p></li>
</ol>
<p>Implement the recursive definition, which is usually straightforward, using <code class="docutils literal notranslate"><span class="pre">...[0]</span></code> for the head of a sequence and <code class="docutils literal notranslate"><span class="pre">...[1:]</span></code> for the tail. If the problem turns out to have overlapping subproblems, then the recursive algorithm may be exponential in the worst case, so test your code on small problem instances.</p>
<p>Once you have a working implementation, modify it to use indices instead of slicing. This improves the run-time and helps introduce a cache later.</p>
<p>When using indices, a recursive definition of function f on sequence <em>items</em> like</p>
<ul class="simple">
<li><p>if <em>items</em> is empty: f(<em>items</em>) = …</p></li>
<li><p>otherwise: f(<em>items</em>) = … head(<em>items</em>) … tail(<em>items</em>) …</p></li>
</ul>
<p>becomes a definition for a function f with an an additional integer parameter <em>index</em>:</p>
<ul class="simple">
<li><p>if <em>index</em> = │<em>items</em>│: f(<em>items</em>, <em>index</em>) = …</p></li>
<li><p>otherwise: f(<em>items</em>, <em>index</em>) = … <em>items</em>[<em>index</em>] … <em>index</em> + 1 …</p></li>
</ul>
<p>The following code template uses an auxiliary inner recursive function that has only parameter <em>index</em> and accesses <em>items</em> from the main function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span><span class="p">:</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">auxiliary</span><span class="p">(</span><span class="n">index</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">):</span>
            <span class="k">return</span> <span class="o">...</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">...</span> <span class="c1"># based on items[index] and index+1</span>

    <span class="k">return</span> <span class="n">auxiliary</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="c1"># start at index 0</span>
</pre></div>
</div>
<ol class="arabic simple" start="3">
<li><p><strong>Are there overlapping subproblems?</strong></p></li>
</ol>
<p>The next step is to show the existence of repeatedly solved subproblems, to justify the need for dynamic programming. You have to think whether it’s possible to arrive at the same subproblem by making different choices whilst processing the input. It may help to draw the tree of recursive calls for a small problem instance to see if repeated nodes appear.</p>
<p>For example, in the <a class="reference internal" href="../23_Dynamic_Programming/23_2_lcs.html#Top-down"><span class="std std-ref">LCS problem</span></a>, whether we first skip the left head and then the right head or vice versa, we obtain the same subproblem. In the knapsack problem, <a class="reference internal" href="../23_Dynamic_Programming/23_3_knapsack.html#Common-subproblems"><span class="std std-ref">if two or more items have the same weight</span></a>, choosing any of them and skipping the others will lead to the same subproblem: the same remaining capacity and the same remaining items to choose from.</p>
<ol class="arabic simple" start="4">
<li><p><strong>Define a cache data structure.</strong></p></li>
</ol>
<p>The subproblems are the possible value combinations for the inputs. The cache is a map of subproblems to their solutions.</p>
<p>If the inputs are one, two, three or more natural numbers, the cache can be implemented as a one-, two-, three- or higher-dimensional array, indexed by the input numbers. For example, the cache for the <a class="reference internal" href="../23_Dynamic_Programming/23_2_lcs.html#Top-down-with-matrix"><span class="std std-ref">LCS problem</span></a> is a two-dimensional array (a matrix) indexed by the indices of the left and right input strings.</p>
<p>If the input values are hashable, like a tuple or a string, the cache can be implemented with a hash table (a Python dictionary). If the input values are comparable but not hashable (like Python lists), consider a binary search tree for logarithmic lookup. You may also consider converting to a hashable data type, like tuples. If there’s no efficient representation for the cache you need, consider going back to step 1 to find an alternative problem with inputs that suit dynamic programming
better.</p>
<ol class="arabic simple" start="5">
<li><p><strong>Implement top-down dynamic programming.</strong></p></li>
</ol>
<p>The next step is to modify the code of step 2 with the cache defined in step 4. The required modifications are usually rote. The original function</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span><span class="p">:</span>
    <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="n">base</span> <span class="n">case</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">...</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">...</span>
</pre></div>
</div>
<p>becomes</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">auxiliary</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">instance</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">cache</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">instance</span> <span class="ow">is</span> <span class="n">base</span> <span class="n">case</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">instance</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">instance</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
        <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="n">instance</span><span class="p">]</span>

    <span class="n">cache</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># initialise cache</span>
    <span class="k">return</span> <span class="n">auxiliary</span><span class="p">(</span><span class="n">instance</span><span class="p">)</span>
</pre></div>
</div>
<p>assuming the cache is a dictionary or array. If the cache is a dictionary, start it empty; if it’s an array, initialise it with an impossible value that can’t be the solution to any subproblem.</p>
<ol class="arabic simple" start="6">
<li><p><strong>Implement bottom-up dynamic programming.</strong></p></li>
</ol>
<p>To develop the bottom-up approach, look at the recurrence relations or the code of the top-down approach to understand in which order to fill the cache. It may help to draw a DAG of the subproblems and their dependencies for a particular problem instance.</p>
<p>The DAG may be easiest to draw by thinking backwards, basically following the recursive call tree and merging common subproblems into one node. However, you may also draw the DAG starting with the base cases and proceeding in a breadth-first way: Which subproblems depend only on the base cases? Which subproblems then depend on the ones just added? In other words, think which subproblems ‘feed’ into which other ones.</p>
<p>The subproblems can then be solved in any topological order of the DAG. If the cache is a multi-dimensional array, it may be as simple to fill as using nested loops, one per dimension. Each loop goes through the corresponding indices in ascending (first to last) or descending (last to first) order. The code becomes:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">f</span><span class="p">(</span><span class="n">instance</span><span class="p">:</span> <span class="o">...</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="o">...</span><span class="p">:</span>
    <span class="n">cache</span> <span class="o">=</span> <span class="o">...</span> <span class="c1"># initialise cache as in top-down approach</span>

    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">...</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">the</span> <span class="n">instance</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">)</span> <span class="ow">is</span> <span class="n">a</span> <span class="n">base</span> <span class="n">case</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cache</span><span class="p">[</span><span class="n">row</span><span class="p">][</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="o">...</span>

    <span class="k">return</span> <span class="n">cache</span><span class="p">[</span><span class="o">...</span><span class="p">][</span><span class="o">...</span><span class="p">]</span>  <span class="c1"># usually one of the corner cells</span>
</pre></div>
</div>
<p>After filling the cache, the algorithm returns the entry corresponding to the input instance.</p>
<p>For example, in the <a class="reference internal" href="../23_Dynamic_Programming/23_2_lcs.html#Bottom-up"><span class="std std-ref">LCS problem</span></a> each matrix cell depends on cells below or to the right in the same row, so both the row and column loops must iterate backwards, in descending index order, and the solution for the input instance is in the top left-hand cell.</p>
<p>However, for the knapsack problem, each cell only depends on <a class="reference internal" href="../23_Dynamic_Programming/23_3_knapsack.html#Top-down-and-bottom-up"><span class="std std-ref">cells below and to the left</span></a>, so we iterate through the rows in descending order and through the columns in ascending order. The final solution is in the top right-hand cell.</p>
<ol class="arabic simple" start="7">
<li><p><strong>Analyse the complexity and measure the performance.</strong></p></li>
</ol>
<p>The worst-case complexity of dynamic programming (either approach) is the size of the cache multiplied by the worst-case complexity of computing each entry. The size of the cache is the number of subproblems, which is at most the product of all possible values for each input.</p>
<p>The top-down approach fills only the part of the cache that is needed for the input problem instance, while bottom-up fills the whole cache. On the other hand, the top-down algorithm makes recursive calls, while bottom-up is purely iterative. Even though the worst-case complexity is the same, the bottom-up approach may have lower run-times if the top-down approach fills most of the cache. You will have to measure the run-times of both approaches for typical inputs to assess which approach is
best in practice.</p>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="25_2_backtracking.html" class="btn btn-neutral float-left" title="25.2. Backtracking" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../26_Complexity_classes/26-introduction.html" class="btn btn-neutral float-right" title="26. Complexity classes" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>