

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>21.4. State graphs</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="21.5. Practice" href="21_5_practice.html" />
    <link rel="prev" title="21.3. Topological sort" href="21_3_topological.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13_Divide/13-introduction.html">13. Divide and conquer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="21-introduction.html">21. Graphs 2</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="21_1_un_components.html">21.1. Undirected graph components</a></li>
<li class="toctree-l2"><a class="reference internal" href="21_2_di_components.html">21.2. Directed graph components</a></li>
<li class="toctree-l2"><a class="reference internal" href="21_3_topological.html">21.3. Topological sort</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">21.4. State graphs</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Problem">21.4.1. Problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Graph">21.4.2. Graph</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Code">21.4.3. Code</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Complexity">21.4.4. Complexity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-21.4.1">Exercise 21.4.1</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="21_5_practice.html">21.5. Practice</a></li>
<li class="toctree-l2"><a class="reference internal" href="21_6_summary.html">21.6. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="21-introduction.html"><span class="section-number">21. </span>Graphs 2</a></li>
      <li class="breadcrumb-item active"><span class="section-number">21.4. </span>State graphs</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="State-graphs">
<h1><span class="section-number">21.4. </span>State graphs<a class="headerlink" href="#State-graphs" title="Link to this heading"></a></h1>
<p>As I mentioned in <a class="reference internal" href="../17_Graphs_1/17_1_modelling.html#Modelling-with-graphs"><span class="std std-ref">Section 17.1</span></a>, directed graphs can represent states and transitions between states. The example I gave was the states of the board during a game of Noughts and Crosses (also known as Tic-tac-toe). The transitions between states are the player moves.</p>
<p>This section shows an example of a problem that can be easily solved if we model it with a state transition graph.</p>
<section id="Problem">
<h2><span class="section-number">21.4.1. </span>Problem<a class="headerlink" href="#Problem" title="Link to this heading"></a></h2>
<p>The problem to solve is similar to the one about a <a class="reference internal" href="../19_Practice-2/19_5_knight.html#A-knight-goes-places"><span class="std std-ref">knight moving on a chessboard</span></a>, but this time using a rook – a chess piece that moves only horizontally or vertically. We’re given a rectangular board of squares, a start square and an end square. We want to find the fewest moves for the rook to go from the start to the end square, with the proviso that moves have to successively be 1, 2, 3, 1, 2, 3, 1, … squares long until the end
square is reached.</p>
<p>This means that the first move goes to an adjacent square, the second move jumps over one square, the third move jumps over two, the fourth move goes again to an adjacent square, etc. If there’s a path (a sequence of moves) from the start to the end that stays within the board, then output the length of the path (the number of moves), otherwise output –1.</p>
<p>The next figure shows a 4×4 board, with a rook symbol on the start square and an E marking the end square. For this input, the output should be four. A path of length four goes first one square right, then two squares right, then three squares down and finally one square left.</p>
<p id="fig-21.4.1"></p><p><a class="reference internal" href="../33_Figures/Figures_21_4.html#Figure-21.4.1"><span class="std std-ref">Figure 21.4.1</span></a></p>
<img alt="Image 21_4_jumps.png" src="../_images/21_4_jumps.png" />
<p>A path that first goes two squares to the right and then three down is shorter, but it’s not a valid path because it doesn’t start with a move of one square.</p>
<p>To check your understanding of the movement, find another shortest valid path from the start to the end, also in four moves.</p>
<hr class="docutils" />
<p>Move one square down, then two squares down, then three to the right and finally one to the left.</p>
<p>As usual, I first construct some test cases. The inputs and output are exactly as for the knight moves problem: three input pairs of integers indicating the size of the board and the coordinates of the start and end squares, and one output integer indicating the shortest path length.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">check_tests</span>

<span class="n">rook_moves_tests</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># case,             size,   start,  end,    moves</span>
    <span class="p">(</span><span class="s1">&#39;1x1 board&#39;</span><span class="p">,</span>       <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>     <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;1 row, 2 cols&#39;</span><span class="p">,</span>   <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>     <span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;start = end&#39;</span><span class="p">,</span>     <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>     <span class="mi">0</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;figure example&#39;</span><span class="p">,</span>  <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>     <span class="mi">4</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;2 away&#39;</span><span class="p">,</span>          <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>    <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">]</span>

<span class="n">check_tests</span><span class="p">(</span><span class="n">rook_moves_tests</span><span class="p">,</span> <span class="p">[</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">,</span> <span class="nb">int</span><span class="p">])</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
OK: the test table passed the automatic checks.
</pre></div></div>
</div>
<div class="admonition note">
<p><strong>Info:</strong> This is a simplification of problem <a class="reference external" href="http://ctp.di.fct.unl.pt/~amd/cpn/2004miup/oficial/problems/I/I.html">Eternal Truths</a> from the 2004 Portuguese University Programming Contest.</p>
</div>
</section>
<section id="Graph">
<h2><span class="section-number">21.4.2. </span>Graph<a class="headerlink" href="#Graph" title="Link to this heading"></a></h2>
<p>The problem asks for the fewest moves. As for the knight moving on a chessboard, this seems to be a shortest path problem on an undirected graph, with one node per square. However, the distance of the move changes in each step, so the neighbours of each square are constantly changing. It seems we need three graphs instead of one.</p>
<p>Here they are for the example board above. In the left-hand graph, the edges connect the adjacent squares. In the middle graph, the edges connect nodes that are two squares away. In the right-hand graph, the edges connect nodes that are three squares away.</p>
<p id="fig-21.4.2"></p><p><a class="reference internal" href="../33_Figures/Figures_21_4.html#Figure-21.4.2"><span class="std std-ref">Figure 21.4.2</span></a></p>
<img alt="Image 21_4_undirected.png" src="../_images/21_4_undirected.png" />
<p>The algorithm would be a modified breadth-first search that is constantly switching between graphs, because the first, fourth, seventh, … moves are done on the left-hand graph, the second, fifth, eighth, … moves are done on the middle graph, the third, sixth, ninth, … moves are done on the right-hand graph. This sounds too complicated and error-prone to me.</p>
<p>We need an approach that uses a single, unchanging graph, because all our graph algorithms work on such graphs, not on graphs where the edges are changing as the algorithm progresses.</p>
<p>The solution is to define a graph that represents the possible states of the rook. As breadth-first search explores the paths from the start node, it needs to know which square the rook is on and what move it can do next. The state of the rook is its current position and the distance of the next move.</p>
<p>For each square S we need three nodes (S, 1), (S, 2) and (S, 3) that represent the three possible states for when the rook is in that square: it can next move by one, two or three squares.</p>
<p>The graph has one edge (A, 1) ⟶ (B, 2) for each square B that is adjacent to square A. The edges state that the rook can move from any square to any adjacent square if the next move is by one square. Once it does the move, the rook is in a state where it next moves by two squares. Likewise there are edges</p>
<ul class="simple">
<li><p>(A, 2) ⟶ (B, 3) for each position B that is two squares away from A</p></li>
<li><p>(A, 3) ⟶ (B, 1) for each position B that is three squares away from A.</p></li>
</ul>
<p>Here’s the state transition graph for a 1×4 board: a single row of four squares.</p>
<p id="fig-21.4.3"></p><p><a class="reference internal" href="../33_Figures/Figures_21_4.html#Figure-21.4.3"><span class="std std-ref">Figure 21.4.3</span></a></p>
<img alt="Image 21_4_states.png" src="../_images/21_4_states.png" />
<p>The layout of the edges shows when the rook can move left or right. The first move, from (A, 1) to (B, 2), goes to the square left or right of A, when possible. The second move, from (A, 2) to (B, 3), goes left or right by two squares when possible. Finally, the third move, from (A, 3) to (B, 1), is only possible from the left-most to the right-most square and vice versa.</p>
<p>Having constructed this graph, we apply BFS to find the shortest path from (<em>start</em>, 1) to (<em>end</em>, <em>move</em>) where <em>move</em> can be any value. Once we reach the end square, we don’t really care what the next move should be.</p>
</section>
<section id="Code">
<h2><span class="section-number">21.4.3. </span>Code<a class="headerlink" href="#Code" title="Link to this heading"></a></h2>
<p>First, I construct the state transition graph.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_digraph


<span class="k">def</span><span class="w"> </span><span class="nf">state_transitions</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DiGraph</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the state transition graph for a board of the given size.</span>

<span class="sd">    Preconditions: size is a pair of positive integers, the number of rows and columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">columns</span> <span class="o">=</span> <span class="n">size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">states</span> <span class="o">=</span> <span class="n">DiGraph</span><span class="p">()</span>
    <span class="c1"># add nodes (S, 1), (S, 2), (S, 3) for every square S</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">rows</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="n">states</span><span class="o">.</span><span class="n">add_node</span><span class="p">(((</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">),</span> <span class="n">move</span><span class="p">))</span>
    <span class="c1"># add edges</span>
    <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">states</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
        <span class="n">position</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">distance</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">row</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">position</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">next_distance</span> <span class="o">=</span> <span class="n">distance</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># 1 -&gt; 2 -&gt; 3 -&gt; 1 -&gt; ...</span>

        <span class="c1"># generate the 4 possible moves: up, left, down, right</span>
        <span class="k">for</span> <span class="n">move</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="n">distance</span><span class="p">,</span> <span class="n">distance</span><span class="p">):</span>
            <span class="c1"># do vertical move if it stays within board</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">row</span> <span class="o">+</span> <span class="n">move</span> <span class="o">&lt;</span> <span class="n">rows</span><span class="p">:</span>
                <span class="n">next_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">row</span> <span class="o">+</span> <span class="n">move</span><span class="p">,</span> <span class="n">column</span><span class="p">),</span> <span class="n">next_distance</span><span class="p">)</span>
                <span class="n">states</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_state</span><span class="p">)</span>
            <span class="c1"># do horizontal move if it stays within board</span>
            <span class="k">if</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">column</span> <span class="o">+</span> <span class="n">move</span> <span class="o">&lt;</span> <span class="n">columns</span><span class="p">:</span>
                <span class="n">next_state</span> <span class="o">=</span> <span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span> <span class="o">+</span> <span class="n">move</span><span class="p">),</span> <span class="n">next_distance</span><span class="p">)</span>
                <span class="n">states</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_state</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">states</span>
</pre></div>
</div>
</div>
<p>Before moving on, I test this function with a small 1×3 board. Remember that the graph layout is semi-random, so you may have to run the next cell a few times to get a more understandable drawing.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">state_transitions</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>  <span class="c1"># single row, three columns</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../_images/21_Graphs_2_21_4_states_13_0.png" src="../_images/21_Graphs_2_21_4_states_13_0.png" />
</div>
</div>
<p>You should be able to see, among other edges, ((0, 1), 1) ⟶ ((0, 0), 2) ⟶ ((0, 2), 3): the rook moves one square left from (0, 1) to (0, 0) and then two squares right to (0, 2). Moving next by three squares would put the rook outside the board.</p>
<p>Next, I copy <a class="reference internal" href="../32_Answers/Answers_19_5_04.html"><span class="doc">the code</span></a> for the knight moves problem and modify it for this problem. I’ll explain the changes after the code.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="o">%</span><span class="k">run</span> -i ../m269_queue


<span class="k">def</span><span class="w"> </span><span class="nf">rook_moves</span><span class="p">(</span><span class="n">size</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the least number of 1, 2, 3, 1, ... rook moves from start to end.</span>

<span class="sd">    Return -1 if end is not reachable from start.</span>

<span class="sd">    Preconditions:</span>
<span class="sd">    - size is a pair (rows, columns) with rows &gt; 0 and columns &gt; 0</span>
<span class="sd">    - start and end are pairs (r, c) with 0 &lt;= r &lt; rows and 0 &lt;= c &lt; columns</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
        <span class="k">return</span> <span class="mi">0</span>

    <span class="n">graph</span> <span class="o">=</span> <span class="n">state_transitions</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>  <span class="c1"># change 1</span>

    <span class="n">initial_state</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># change 2</span>
    <span class="n">visited</span> <span class="o">=</span> <span class="p">{</span><span class="n">initial_state</span><span class="p">}</span>  <span class="c1"># change 2</span>
    <span class="n">unprocessed</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">initial_state</span><span class="p">):</span>  <span class="c1"># change 2</span>
        <span class="n">unprocessed</span><span class="o">.</span><span class="n">enqueue</span><span class="p">((</span><span class="n">neighbour</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># change 4</span>
    <span class="k">while</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="n">unprocessed</span><span class="o">.</span><span class="n">dequeue</span><span class="p">()</span>
        <span class="n">current</span> <span class="o">=</span> <span class="n">to_visit</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">to_visit</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># change 3</span>
            <span class="k">return</span> <span class="n">length</span>
        <span class="k">elif</span> <span class="n">current</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">neighbour</span> <span class="ow">in</span> <span class="n">graph</span><span class="o">.</span><span class="n">out_neighbours</span><span class="p">(</span><span class="n">current</span><span class="p">):</span>
                <span class="n">unprocessed</span><span class="o">.</span><span class="n">enqueue</span><span class="p">((</span><span class="n">neighbour</span><span class="p">,</span> <span class="n">length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># change 4</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
</pre></div>
</div>
</div>
<p>The changes were as follows, besides the trivial modifications to the header and docstring.</p>
<ol class="arabic simple">
<li><p>Replace the code that creates the graph for the knight’s moves with a call to <code class="docutils literal notranslate"><span class="pre">state_transitions</span></code>.</p></li>
<li><p>The initial node is <code class="docutils literal notranslate"><span class="pre">(start,</span> <span class="pre">1)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">start</span></code> because nodes now represent states, not squares.</p></li>
<li><p>For the same reason, extract the square from the <code class="docutils literal notranslate"><span class="pre">current</span></code> node before comparing it to the <code class="docutils literal notranslate"><span class="pre">end</span></code> square.</p></li>
<li><p>Further simplify the BFS algorithm, which I could have already done for the knight moves problem. Instead of adding to the queue edge (A, B) with the length of the path to B, I just add B and the length, because the shortest path is not asked for, only its length.</p></li>
</ol>
<p>Finally, let’s run the code on the test table created at the start.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">test</span>

<span class="n">test</span><span class="p">(</span><span class="n">rook_moves</span><span class="p">,</span> <span class="n">rook_moves_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Testing rook_moves...
Tests finished: 5 passed (100%), 0 failed.
</pre></div></div>
</div>
<p>The moral of this and similar problems is:</p>
<div class="admonition warning">
<p><strong>Note:</strong> Instead of inventing a new graph algorithm, model the problem with a graph that allows you to apply or adapt a standard graph algorithm.</p>
</div>
<p>Nodes can represent anything, including places, tasks, events, states. Edges may be weighted and directed. This gives graphs a great modelling power. Once we represent the input as a graph, we can often solve the problem with a standard graph algorithm or some small adaptation of it, as done above, because many graph problems fall into one of a small number of categories: find a shortest path, a minimum spanning tree, a topological sort or the graph’s components.</p>
</section>
<section id="Complexity">
<h2><span class="section-number">21.4.4. </span>Complexity<a class="headerlink" href="#Complexity" title="Link to this heading"></a></h2>
<p>The complexity of this kind of approach (transform the input into a graph and apply a graph algorithm) is Θ(<em>n</em> + <em>e</em>) to construct the graph plus whatever the complexity of the graph algorithm is. For this problem, the algorithm used is BFS so the overall complexity is Θ(<em>n</em> + <em>e</em>) + Θ(<em>n</em> + <em>e</em>) = Θ(<em>n</em> + <em>e</em>).</p>
<p>However, the complexity must be stated in terms of the input, not of the constructed graph. We must determine the number of nodes and edges in terms of the input variables, and restate the complexity in those terms.</p>
<section id="Exercise-21.4.1">
<h3>Exercise 21.4.1<a class="headerlink" href="#Exercise-21.4.1" title="Link to this heading"></a></h3>
<p>The main input variable is the size of the board: the number of rows <em>r</em> and the number of columns <em>c</em>.</p>
<ol class="arabic simple">
<li><p>How many nodes does the state transition graph have, in terms of <em>r</em> and <em>c</em>? In other words, give an expression for <em>n</em>, using <em>r</em> and <em>c</em>.</p></li>
<li><p>How many edges does the state transition graph have at most? State <em>e</em> as an expression in terms of <em>r</em> and <em>c</em>.</p></li>
<li><p>Using the previous expressions, give the complexity Θ(<em>n</em> + <em>e</em>) in terms of <em>r</em> and <em>c</em>.</p></li>
</ol>
<p><a class="reference internal" href="../31_Hints/Hints_21_4_01.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_21_4_01.html"><span class="doc">Answer</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="21_3_topological.html" class="btn btn-neutral float-left" title="21.3. Topological sort" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="21_5_practice.html" class="btn btn-neutral float-right" title="21.5. Practice" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>