

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>13.6. Divide and conquer</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13.7. Summary" href="13_7_summary.html" />
    <link rel="prev" title="13.5. Binary search variants" href="13_5_variants.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="13-introduction.html">13. Divide and conquer</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="13_1_decrease_one.html">13.1. Decrease by one</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_2_decrease_half.html">13.2. Decrease by half</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_3_variable_decrease.html">13.3. Variable decrease</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_4_binary_search.html">13.4. Binary search</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_5_variants.html">13.5. Binary search variants</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">13.6. Divide and conquer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Complexity">13.6.1. Complexity</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Maximum-with-slicing">Maximum with slicing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Maximum-without-slicing">Maximum without slicing</a></li>
<li class="toctree-l4"><a class="reference internal" href="#General-comments">General comments</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="13_7_summary.html">13.7. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="13-introduction.html"><span class="section-number">13. </span>Divide and conquer</a></li>
      <li class="breadcrumb-item active"><span class="section-number">13.6. </span>Divide and conquer</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Divide-and-conquer">
<h1><span class="section-number">13.6. </span>Divide and conquer<a class="headerlink" href="#Divide-and-conquer" title="Link to this heading"></a></h1>
<p>A decrease-and-conquer algorithm may divide the input into multiple parts, but only conquers (i.e. solves the problem for) one of them. Binary search is an example: the input sequence is divided into two halves, but only one of them is searched.</p>
<p>A divide-and-conquer algorithm conquers more than one part, usually all of them, and then combines their solutions. The <a class="reference internal" href="../12_Recursion/12_7_multiple.html#Multiple-recursion"><span class="std std-ref">multiple recursion</span></a> examples in the previous chapter are divide-and-conquer algorithms.</p>
<section id="Complexity">
<h2><span class="section-number">13.6.1. </span>Complexity<a class="headerlink" href="#Complexity" title="Link to this heading"></a></h2>
<p>Let <em>n</em> be the size of the input and <em>s</em> be the size of the smallest input, which is necessarily a base case. Let’s assume the algorithm divides the input into <em>p</em> parts of equal or nearly equal size. Then its complexity is defined by</p>
<ul class="simple">
<li><p>if <em>n</em> = <em>s</em>: T(<em>n</em>) = Θ(<em>b</em>)</p></li>
<li><p>if <em>n</em> &gt; <em>s</em>: T(<em>n</em>) = Θ(<em>d</em>) + <em>p</em> × T(<em>n</em> / <em>p</em>) + Θ(<em>c</em>)</p></li>
</ul>
<p>where Θ(<em>b</em>) is the complexity of handling the base case, Θ(<em>d</em>) is the complexity of dividing the input and Θ(<em>c</em>) is the complexity of combining the subsolutions for the parts.</p>
<p>The expression <em>p</em> × T(<em>n</em> / <em>p</em>) is the time it takes to solve the <em>p</em> subproblems, each of size <em>n</em> / <em>p</em>.</p>
<p>Let’s analyse the complexity of the divide-and-conquer algorithm for maximum(<em>numbers</em>, <em>start</em>, <em>end</em>), presented in the previous chapter. Remember that the input sequence isn’t empty.</p>
<section id="Maximum-with-slicing">
<h3>Maximum with slicing<a class="headerlink" href="#Maximum-with-slicing" title="Link to this heading"></a></h3>
<p>The first algorithm presented was:</p>
<ol class="arabic simple">
<li><p>let <em>n</em> be │<em>numbers</em>│</p></li>
<li><p>if <em>n</em> = 1:</p>
<ol class="arabic simple">
<li><p>let <em>solution</em> be head(<em>numbers</em>)</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>middle</em> be floor(<em>n</em> / 2)</p></li>
<li><p>let <em>largest left</em> be maximum(<em>numbers</em>[0:<em>middle</em>])</p></li>
<li><p>let <em>largest right</em> be maximum(<em>numbers</em>[<em>middle</em>:<em>n</em>])</p></li>
<li><p>let <em>solution</em> be max(<em>largest left</em>, <em>largest right</em>)</p></li>
</ol>
</li>
</ol>
<p>The base case has size <em>s</em> = 1 and takes constant time to process (step 2.1). Steps 3.1 to 3.3 take linear time to divide the input into <em>p</em> = 2 parts. Step 3.4 takes constant time to combine the subsolutions. We have:</p>
<ul class="simple">
<li><p>if <em>n</em> = 1: T(<em>n</em>) = Θ(1)</p></li>
<li><p>if <em>n</em> &gt; 1: T(<em>n</em>) = Θ(<em>n</em>) + 2 × T(<em>n</em> / 2) + Θ(1) = 2×T(<em>n</em> / 2) + Θ(<em>n</em>).</p></li>
</ul>
<p>It has been proven that this corresponds to T(<em>n</em>) = Θ(<em>n</em> × log <em>n</em>). This is called <strong>log-linear</strong> complexity. It’s slightly worse than linear but much better than quadratic complexity, because logarithmic run-times grow very slowly as the input size grows. In maths, the multiplication operator is omitted when that causes no confusion, so we usually write Θ(<em>n</em> log <em>n</em>).</p>
<div class="admonition note">
<p><strong>Info:</strong> Log-linear complexity is also called linearithmic complexity.</p>
</div>
</section>
<section id="Maximum-without-slicing">
<h3>Maximum without slicing<a class="headerlink" href="#Maximum-without-slicing" title="Link to this heading"></a></h3>
<p>The second version presented was:</p>
<ol class="arabic simple">
<li><p>if <em>start</em> + 1 = <em>end</em>:</p>
<ol class="arabic simple">
<li><p>let <em>solution</em> be <em>numbers</em>[<em>start</em>]</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>middle</em> be <em>start</em> + floor((<em>end</em> – <em>start</em>) / 2)</p></li>
<li><p>let <em>largest left</em> be maximum(<em>numbers</em>, <em>start</em>, <em>middle</em>)</p></li>
<li><p>let <em>largest right</em> be maximum(<em>numbers</em>, <em>middle</em>, <em>end</em>)</p></li>
<li><p>let <em>solution</em> be max(<em>largest left</em>, <em>largest right</em>)</p></li>
</ol>
</li>
</ol>
<p>The base case has size <em>s</em> = 1 and takes constant time to process (step 1.1). Steps 2.1 to 2.3 take constant time to divide the input into <em>p</em> = 2 parts. Step 2.4 takes constant time to combine the subsolutions. We have:</p>
<ul class="simple">
<li><p>if <em>n</em> = 1: T(<em>n</em>) = Θ(1)</p></li>
<li><p>if <em>n</em> &gt; 1: T(<em>n</em>) = Θ(1) + 2 × T(<em>n</em> / 2) + Θ(1) = 2×T(<em>n</em> / 2) + Θ(1).</p></li>
</ul>
<p>It has been proven that this corresponds to T(<em>n</em>) = Θ(<em>n</em>).</p>
</section>
<section id="General-comments">
<h3>General comments<a class="headerlink" href="#General-comments" title="Link to this heading"></a></h3>
<p>The direct expressions for T(<em>n</em>) remain the same for any other <em>p</em> &gt; 2, as long as dividing and combining takes constant time. In other words, dividing into more than two parts and combining their results doesn’t reduce the complexity but complicates the algorithm and increases the run-time. Therefore, most divide-and-conquer algorithms just divide the input into halves.</p>
<div class="admonition warning">
<p><strong>Note:</strong> If T(<em>s</em>) = Θ(1), where <em>s</em> is the smallest input size, and T(<em>n</em>) = <em>p</em> × T(<em>n</em> / <em>p</em>) + Θ(1) for <em>n</em> &gt; <em>s</em> and <em>p</em> &gt; 1, then T(<em>n</em>) = Θ(<em>n</em>). If instead T(<em>n</em>) = <em>p</em> × T(<em>n</em> / <em>p</em>) + Θ(<em>n</em>), then T(<em>n</em>) = Θ(<em>n</em> log <em>n</em>).</p>
</div>
<p>If a divide-and-conquer algorithm, like the one above, does the same steps for all inputs, i.e. there’s no input for which it stops early, then the complexity obtained is both the best- and worst-case complexity. Otherwise, the recursive definition captures the worst-case complexity.</p>
<p>The analysis shows that it’s not worth computing the maximum with a divide-and-conquer algorithm: it isn’t more efficient than a much simpler iterative linear search. The next chapter presents two examples in which divide and conquer pays off.</p>
<p>Divide and conquer is a good approach if implemented in a parallel fashion to take advantage of multi-processor hardware. Each recursive call can be executed as a separate thread that works independently on its part of the input. The operating system allocates each thread to an available processor, reducing the time the user waits for the result, compared to executing the algorithm in one thread. Writing a multi-threaded algorithm requires special libraries or programming language constructs
that are outside the scope of M269.</p>
<div class="admonition note">
<p><strong>Info:</strong> The Operating Systems block of TM129 introduces threads.</p>
</div>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="13_5_variants.html" class="btn btn-neutral float-left" title="13.5. Binary search variants" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="13_7_summary.html" class="btn btn-neutral float-right" title="13.7. Summary" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>