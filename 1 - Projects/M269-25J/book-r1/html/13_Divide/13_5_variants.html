

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>13.5. Binary search variants</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13.6. Divide and conquer" href="13_6_divide.html" />
    <link rel="prev" title="13.4. Binary search" href="13_4_binary_search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="13-introduction.html">13. Divide and conquer</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="13_1_decrease_one.html">13.1. Decrease by one</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_2_decrease_half.html">13.2. Decrease by half</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_3_variable_decrease.html">13.3. Variable decrease</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_4_binary_search.html">13.4. Binary search</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">13.5. Binary search variants</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Transition">13.5.1. Transition</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-13.5.1">Exercise 13.5.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-13.5.2">Exercise 13.5.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Right-number-in-the-right-place">13.5.2. Right number in the right place</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-13.5.3">Exercise 13.5.3</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="13_6_divide.html">13.6. Divide and conquer</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_7_summary.html">13.7. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="13-introduction.html"><span class="section-number">13. </span>Divide and conquer</a></li>
      <li class="breadcrumb-item active"><span class="section-number">13.5. </span>Binary search variants</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Binary-search-variants">
<h1><span class="section-number">13.5. </span>Binary search variants<a class="headerlink" href="#Binary-search-variants" title="Link to this heading"></a></h1>
<p>Binary search can be adapted to other problems, for example if we don’t know the value being searched for, only some property of it.</p>
<p>To design a binary search we must answer these questions:</p>
<ol class="arabic simple">
<li><p>When can we know the search is unsuccessful and stop?</p></li>
<li><p>When can we know the search is successful and stop?</p></li>
<li><p>How do we decide whether to search the left or the right half of the sequence?</p></li>
</ol>
<p>For the basic binary search in the previous section, the answers are:</p>
<ol class="arabic simple">
<li><p>When the sequence is empty.</p></li>
<li><p>When the middle item is the sought item.</p></li>
<li><p>If the sought item is smaller than the middle item, search the left half; otherwise search the right half.</p></li>
</ol>
<section id="Transition">
<h2><span class="section-number">13.5.1. </span>Transition<a class="headerlink" href="#Transition" title="Link to this heading"></a></h2>
<p>Consider the problem of finding the transition between negative and positive numbers in an ascending sequence. More precisely, we want the index of the first positive number. Let’s assume there’s always at least one. We don’t know its value: it might be 1, 5486, or anything else. Still, we can use binary search to find it.</p>
<div class="admonition note">
<p><strong>Info:</strong> This problem is inspired by LeetCode problem <a class="reference external" href="https://leetcode.com/problems/first-bad-version/">278</a>.</p>
</div>
<p>We’re assuming there’s a positive number in the sequence, so the search is always successful and question 1 doesn’t apply.</p>
<p>What’s the answer to question 2, i.e. when can we stop, having found a positive number? Can we stop when the middle number is positive?</p>
<hr class="docutils" />
<p>No we can’t, because there might be other positive numbers to its left. We only stop when the current slice has a single number: it must be positive.</p>
<p>What’s the answer to question 3? How do we determine which half to search?</p>
<hr class="docutils" />
<p>If the middle number is not positive, any positive numbers must come after it because the sequence is ascending, so we search the right half. Otherwise we search the left half. We can’t exclude the middle item when searching the left half, because it might be the first positive number.</p>
<p>Here’s an algorithm for function first_positive(<em>numbers</em>, <em>start</em>, <em>end</em>), with 0 ≤ <em>start</em> &lt; <em>end</em> ≤ │<em>numbers</em>│. Contrary to previous binary searches, the input sequence isn’t empty (there’s at least one positive number), so the start index is strictly smaller than the end index.</p>
<ol class="arabic simple">
<li><p>if <em>end</em> − <em>start</em> = 1:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be <em>numbers</em>[<em>start</em>]</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>middle</em> be <em>start</em> + floor((<em>end</em> – <em>start</em>) / 2)</p></li>
<li><p>let <em>middle item</em> be <em>numbers</em>[<em>middle</em>]</p></li>
<li><p>if <em>middle item</em> &gt; 0:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be first_positive(<em>numbers</em>, <em>start</em>, <em>middle</em> + 1)</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be first_positive(<em>numbers</em>, <em>middle</em> + 1, <em>end</em>)</p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Since we’re working on slices, we’re following the convention of not including the end index. Step 2.3.1 must therefore set it to <em>middle</em> + 1 in order to include the middle item.</p>
<p>This raises the question of whether the slice is always reducing its length. Length one is already handled as a base case by step 1. Let’s assume the length is two, i.e. <em>end</em> – <em>start</em> = 2. In that case</p>
<p><em>middle</em> = <em>start</em> + floor((<em>end</em> – <em>start</em>) / 2) = <em>start</em> + floor(2 / 2) = <em>start</em> + 1</p>
<p>which means that the middle number is the second and last number of the slice. It can’t be negative because any positive number would have to come after it, but there are no more numbers in a slice of length 2. So, the middle (actually last) number of the two must be positive. The algorithm will execute step 2.3.1 but <em>middle</em> + 1 = <em>start</em> + 2 = <em>end</em>, which means that the recursive call will be made on the same slice. To sum up, when the slice has only two numbers, the second, which must be
positive, is chosen as the middle number and the recursive call doesn’t decrease the slice.</p>
<p>We must handle this input size as a separate base case and choose either the first number, if both are positive, or else the second number.</p>
<ol class="arabic simple" start="2">
<li><p>otherwise if <em>end</em> – <em>start</em> = 2:</p>
<ol class="arabic simple">
<li><p>if <em>numbers</em>[<em>start</em>] &gt; 0:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be <em>numbers</em>[<em>start</em>]</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be <em>numbers</em>[<em>start</em> + 1]</p></li>
</ol>
</li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>…</p></li>
</ol>
</li>
</ol>
<p>Next we must analyse the case <em>end</em> – <em>start</em> = 3. Again,</p>
<p><em>middle</em> = <em>start</em> + floor((<em>end</em> – <em>start</em>) / 2) = <em>start</em> + floor(3 / 2) = <em>start</em> + 1</p>
<p>but now this means that <em>start</em> &lt; <em>middle</em> + 1 &lt; <em>end</em>. So, whether the algorithm takes the left half (<em>start</em> to <em>middle</em> + 1) or the right half (<em>middle</em> + 1 to <em>end</em>), the new slice is smaller than the input slice from <em>start</em> to <em>end</em> and there’s no risk of infinite recursion.</p>
<div class="admonition warning">
<p><strong>Note:</strong> Check that the recursive calls reduce the input’s size or value. Any case for which they don’t must be handled as a base case.</p>
</div>
<section id="Exercise-13.5.1">
<h3>Exercise 13.5.1<a class="headerlink" href="#Exercise-13.5.1" title="Link to this heading"></a></h3>
<p>Implement the inner auxiliary function below recursively and run the tests.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">test</span>


<span class="k">def</span><span class="w"> </span><span class="nf">first_positive</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return the first (lowest index) positive integer in numbers.</span>

<span class="sd">    Preconditions:</span>
<span class="sd">    - numbers is a list of integers in ascending order</span>
<span class="sd">    - numbers has a positive integer</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_slice</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the first positive number within numbers[start:end].</span>

<span class="sd">        Preconditions: 0 &lt;= start &lt; end &lt;= len(items)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">pass</span>

    <span class="k">return</span> <span class="n">in_slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span>


<span class="n">first_positive_tests</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># case,             numbers,            first</span>
    <span class="p">(</span><span class="s1">&#39;one number&#39;</span><span class="p">,</span>      <span class="p">[</span><span class="mi">1</span><span class="p">],</span>                    <span class="mi">1</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is last&#39;</span><span class="p">,</span>         <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span>         <span class="mi">3</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;all positive&#39;</span><span class="p">,</span>    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span>              <span class="mi">2</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;all but first&#39;</span><span class="p">,</span>   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>  <span class="mi">1</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">test</span><span class="p">(</span><span class="n">first_positive</span><span class="p">,</span> <span class="n">first_positive_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../32_Answers/Answers_13_5_01.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Exercise-13.5.2">
<h3>Exercise 13.5.2<a class="headerlink" href="#Exercise-13.5.2" title="Link to this heading"></a></h3>
<p>Implement the function iteratively. The docstring isn’t repeated.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">first_positive</span><span class="p">(</span><span class="n">numbers</span><span class="p">:</span> <span class="nb">list</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>  <span class="c1"># noqa: D103</span>
    <span class="k">pass</span>


<span class="n">test</span><span class="p">(</span><span class="n">first_positive</span><span class="p">,</span> <span class="n">first_positive_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p><a class="reference internal" href="../31_Hints/Hints_13_5_02.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_13_5_02.html"><span class="doc">Answer</span></a></p>
<p>There’s a more efficient version with a more general base case: if the start number is positive, no matter how long the slice is, then we’ve found the first positive integer and we can stop. Once a slice of only positive numbers is obtained, this version stops whereas the version above continues decreasing the slice until it has only one or two numbers. This new version has worst-case complexity O(log │<em>numbers</em>│), since it’s more efficient for some inputs. The recursive algorithm starts as
follows:</p>
<ol class="arabic simple">
<li><p>if <em>numbers</em>[<em>start</em>] &gt; 0:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be <em>numbers</em>[<em>start</em>]</p></li>
</ol>
</li>
<li><p>otherwise if <em>end</em> – <em>start</em> = 2:</p>
<ol class="arabic simple">
<li><p>let <em>first</em> be <em>numbers</em>[<em>start</em> + 1]</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>…</p></li>
</ol>
</li>
</ol>
<p>If the slice has two numbers (step 2 is true) and the first one isn’t positive (step 1 is false), then the second one must be positive (step 2.1).</p>
</section>
</section>
<section id="Right-number-in-the-right-place">
<h2><span class="section-number">13.5.2. </span>Right number in the right place<a class="headerlink" href="#Right-number-in-the-right-place" title="Link to this heading"></a></h2>
<p>Given <em>numbers</em>, an ascending sequence of integers without duplicates, we want to know if there’s an index <em>i</em> such that <em>numbers</em>[<em>i</em>] = <em>i</em>. For example, (1, 2, 3) doesn’t have any number that matches its index, but for (-1, 0, 2), number 2 is at index 2.</p>
<p>Like the previous problem, this one can be easily solved with a linear search, but you can do much better than that.</p>
<section id="Exercise-13.5.3">
<h3>Exercise 13.5.3<a class="headerlink" href="#Exercise-13.5.3" title="Link to this heading"></a></h3>
<p>Solve this decision problem using iterative or recursive binary search. You can outline an algorithm or write it in full, whatever you prefer. Think about the three questions at the start of this section.</p>
<p><a class="reference internal" href="../31_Hints/Hints_13_5_03.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_13_5_03.html"><span class="doc">Answer</span></a></p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="13_4_binary_search.html" class="btn btn-neutral float-left" title="13.4. Binary search" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="13_6_divide.html" class="btn btn-neutral float-right" title="13.6. Divide and conquer" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>