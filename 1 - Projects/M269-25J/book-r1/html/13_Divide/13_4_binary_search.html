

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>13.4. Binary search</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../_static/nbsphinx-code-cells.css?v=2aa19091" />
      <link rel="stylesheet" type="text/css" href="../_static/m269.css?v=4f7d186f" />

  
      <script src="../_static/jquery.js?v=5d32c60e"></script>
      <script src="../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../_static/documentation_options.js?v=7f41d439"></script>
      <script src="../_static/doctools.js?v=9bcbadda"></script>
      <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="13.5. Binary search variants" href="13_5_variants.html" />
    <link rel="prev" title="13.3. Variable decrease" href="13_3_variable_decrease.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            M269
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01_Introduction/01-introduction.html">1. Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02_Sequence/02-introduction.html">2. Numbers and sequence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03_Selection/03-introduction.html">3. Booleans and selection</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04_Iteration/04-introduction.html">4. Sequences and iteration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05_TMA01-1/05-introduction.html">5. TMA 01 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../06_Implementing/06-introduction.html">6. Implementing sequences</a></li>
<li class="toctree-l1"><a class="reference internal" href="../07_Ordered/07-introduction.html">7. Stacks and queues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08_Unordered/08-introduction.html">8. Unordered collections</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09_Practice-1/09-introduction.html">9. Practice 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10_TMA01-2/10-introduction.html">10. TMA 01 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11_Search/11-introduction.html">11. Exhaustive search</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12_Recursion/12-introduction.html">12. Recursion</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="13-introduction.html">13. Divide and conquer</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="13_1_decrease_one.html">13.1. Decrease by one</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_2_decrease_half.html">13.2. Decrease by half</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_3_variable_decrease.html">13.3. Variable decrease</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">13.4. Binary search</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Recursive,-with-slicing">13.4.1. Recursive, with slicing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Algorithm">Algorithm</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-13.4.1">Exercise 13.4.1</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Complexity">Complexity</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Recursive,-without-slicing">13.4.2. Recursive, without slicing</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Exercise-13.4.2">Exercise 13.4.2</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Iterative">13.4.3. Iterative</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="13_5_variants.html">13.5. Binary search variants</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_6_divide.html">13.6. Divide and conquer</a></li>
<li class="toctree-l2"><a class="reference internal" href="13_7_summary.html">13.7. Summary</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../14_Sorting/14-introduction.html">14. Sorting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15_TMA02-1/15-introduction.html">15. TMA 02 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16_Trees/16-introduction.html">16. Rooted trees</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17_Graphs_1/17-introduction.html">17. Graphs 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18_Greed/18-introduction.html">18. Greed</a></li>
<li class="toctree-l1"><a class="reference internal" href="../19_Practice-2/19-introduction.html">19. Practice 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../20_TMA02-2/20-introduction.html">20. TMA 02 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../21_Graphs_2/21-introduction.html">21. Graphs 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../22_Backtracking/22-introduction.html">22. Backtracking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../23_Dynamic_Programming/23-introduction.html">23. Dynamic Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../24_Practice-3/24-introduction.html">24. Practice 3</a></li>
<li class="toctree-l1"><a class="reference internal" href="../25_TMA03-1/25-introduction.html">25. TMA 03 part 1</a></li>
<li class="toctree-l1"><a class="reference internal" href="../26_Complexity_classes/26-introduction.html">26. Complexity classes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../27_Computability/27-introduction.html">27. Computability</a></li>
<li class="toctree-l1"><a class="reference internal" href="../28_TMA03-2/28-introduction.html">28. TMA 03 part 2</a></li>
<li class="toctree-l1"><a class="reference internal" href="../31_Hints/31-introduction.html">29. Hints</a></li>
<li class="toctree-l1"><a class="reference internal" href="../32_Answers/32-introduction.html">30. Answers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../33_Figures/33-introduction.html">31. Figures</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">M269</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="13-introduction.html"><span class="section-number">13. </span>Divide and conquer</a></li>
      <li class="breadcrumb-item active"><span class="section-number">13.4. </span>Binary search</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Binary-search">
<h1><span class="section-number">13.4. </span>Binary search<a class="headerlink" href="#Binary-search" title="Link to this heading"></a></h1>
<p>In Chapter 11 you saw that searching for an item <em>x</em> in an ascending sequence is often faster than in an unsorted sequence because we can stop when the current item is larger than <em>x</em>: at that point we know <em>x</em> can’t be in the rest of the sequence.</p>
<p>We can search in a sorted sequence much faster with <strong>binary search</strong>. It’s a generate-and-test algorithm that generates very few candidates because it decreases the search space by half after testing the current candidate. Binary search is a decrease-and-conquer algorithm and not an exhaustive search because it doesn’t go through all candidates.</p>
<section id="Recursive,-with-slicing">
<h2><span class="section-number">13.4.1. </span>Recursive, with slicing<a class="headerlink" href="#Recursive,-with-slicing" title="Link to this heading"></a></h2>
<p>Binary search implements the membership operation on sorted sequences. If I’m looking for 4 in the ascending sequence (…, 5, …), then the number must be in the left part, before the 5, if it exists. If the sequence is in descending order instead, then the 4 must be in the right part, after the 5. More generally, inspecting the middle element of a sorted sequence will always discard half of the items no matter where the sought item is and whether the order is ascending or descending.</p>
<section id="Algorithm">
<h3>Algorithm<a class="headerlink" href="#Algorithm" title="Link to this heading"></a></h3>
<p>The algorithm stops when it reaches one of two base cases: either the middle element is the sought element or the sequence is empty. Here’s the recursive definition for has(<em>items</em>, <em>item</em>), assuming that the sequence is in ascending order.</p>
<ul class="simple">
<li><p>if <em>items</em> is empty: has(<em>items</em>, <em>item</em>) = false</p></li>
<li><p>if <em>item</em> = middle element of <em>items</em>: has(<em>items</em>, <em>item</em>) = true</p></li>
<li><p>if <em>item</em> &lt; middle element of <em>items</em>: has(<em>items</em>, <em>item</em>) = has(left half of <em>items</em>, <em>item</em>)</p></li>
<li><p>if <em>item</em> &gt; middle element of <em>items</em>: has(<em>items</em>, <em>item</em>) = has(right half of <em>items</em>, <em>item</em>)</p></li>
</ul>
<p>I defined the function in informal terms to convey the gist of binary search. The algorithm computes the middle element and slices each half as done before for <a class="reference internal" href="../12_Recursion/12_7_multiple.html#Dividing-the-input"><span class="std std-ref">computing the maximum</span></a>.</p>
<ol class="arabic simple">
<li><p>let <em>n</em> be │<em>items</em>│</p></li>
<li><p>if <em>n</em> = 0:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be false</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>middle</em> be floor(<em>n</em> / 2)</p></li>
<li><p>let <em>middle item</em> be <em>items</em>[<em>middle</em>]</p></li>
<li><p>if <em>middle item</em> = <em>item</em>:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be true</p></li>
</ol>
</li>
<li><p>otherwise if <em>item</em> &lt; <em>middle item</em>:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be has(<em>items</em>[0:<em>middle</em>], <em>item</em>)</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be has(<em>items</em>[<em>middle</em> + 1:<em>n</em>], <em>item</em>)</p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>Contrary to the <a class="reference internal" href="../12_Recursion/12_7_multiple.html#Exercise-12.7.1"><span class="std std-ref">multiple recursion membership algorithm</span></a>, this one searches only one of the halves: it’s a single-recursion algorithm. The difference between multiple and single recursion is not about how many recursive calls are in the algorithm, but how many are executed.</p>
<p>Steps 2 and 3.3 check for the base cases; steps 3.4.1 and 3.5.1 decrease the sequence and recur. There’s no combination step, so the algorithm is tail recursive: the last step is either 3.4.1 or 3.5.1.</p>
<p>Neither half includes the middle item (remember that the last index of a slice isn’t included), so each recursive call does indeed reduce the size of the input. We don’t need another base case.</p>
</section>
<section id="Exercise-13.4.1">
<h3>Exercise 13.4.1<a class="headerlink" href="#Exercise-13.4.1" title="Link to this heading"></a></h3>
<p>How would you change the algorithm if the sequence were in descending order? Just describe the change briefly: don’t write the full algorithm.</p>
<p><a class="reference internal" href="../32_Answers/Answers_13_4_01.html"><span class="doc">Answer</span></a></p>
</section>
<section id="Complexity">
<h3>Complexity<a class="headerlink" href="#Complexity" title="Link to this heading"></a></h3>
<p>In the best-case scenario, the middle element is the sought one: the algorithm takes constant time.</p>
<p>In a worst-case scenario, the sequence doesn’t contain the item. We can define the complexity T(<em>n</em>) recursively, using <em>n</em> = │<em>items</em>│. The base case (steps 2 and 2.1) takes constant time, so T(0) = Θ(1). For a non-empty sequence, each call takes</p>
<ul class="simple">
<li><p>Θ(1) for steps 3.1 to 3.3 (which fails in the worst case) and 3.4 or 3.5</p></li>
<li><p>Θ(<em>n</em> / 2) for slicing half the sequence in either 3.4.1 or 3.5.1</p></li>
<li><p>T(<em>n</em> / 2) for the recursive call in the same step.</p></li>
</ul>
<p>Putting it all together:</p>
<ul class="simple">
<li><p>if <em>n</em> = 0: T(<em>n</em>) = Θ(1)</p></li>
<li><p>if <em>n</em> &gt; 0: T(<em>n</em>) = Θ(1) + Θ(<em>n</em> / 2) + T(<em>n</em> / 2) = T(<em>n</em> / 2) + Θ(<em>n</em>).</p></li>
</ul>
<p>It has been proven that this leads to T(<em>n</em>) = Θ(<em>n</em>).</p>
<div class="admonition warning">
<p><strong>Note:</strong> If T(0) = Θ(1) and T(<em>n</em>) = T(<em>n</em> / 2) + Θ(<em>n</em>), then T(<em>n</em>) = Θ(<em>n</em>).</p>
</div>
</section>
</section>
<section id="Recursive,-without-slicing">
<h2><span class="section-number">13.4.2. </span>Recursive, without slicing<a class="headerlink" href="#Recursive,-without-slicing" title="Link to this heading"></a></h2>
<p>Binary search with slicing is no better than linear search in terms of complexity and is much worse in terms of memory due to all the intermediate slices created. To make the algorithm more efficient, I keep track of the start and end indices of the slice to <a class="reference internal" href="../12_Recursion/12_6_avoid_slicing.html#Avoiding-slicing"><span class="std std-ref">avoid creating it</span></a>.</p>
<p>Here’s the recursive binary search algorithm for membership function has(<em>items</em>, <em>item</em>, <em>start</em>, <em>end</em>), with 0 ≤ <em>start</em> ≤ <em>end</em> ≤ │<em>items</em>│.</p>
<ol class="arabic simple">
<li><p>if <em>start</em> = <em>end</em>:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be false</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>middle</em> be <em>start</em> + floor((<em>end</em> – <em>start</em>) / 2)</p></li>
<li><p>let <em>middle item</em> be <em>items</em>[<em>middle</em>]</p></li>
<li><p>if <em>middle item</em> = <em>item</em>:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be true</p></li>
</ol>
</li>
<li><p>otherwise if <em>item</em> &lt; <em>middle item</em>:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be has(<em>items</em>, <em>item</em>, <em>start</em>, <em>middle</em>)</p></li>
</ol>
</li>
<li><p>otherwise:</p>
<ol class="arabic simple">
<li><p>let <em>exists</em> be has(<em>items</em>, <em>item</em>, <em>middle</em> + 1, <em>end</em>)</p></li>
</ol>
</li>
</ol>
</li>
</ol>
<p>I code the algorithm with an inner function to hide the extra arguments from the user. I add a print statement that shows the sequence searched in each call. Feel free to uncomment it and to also print the middle item.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return True if and only if item is a member of items.</span>

<span class="sd">    Preconditions:</span>
<span class="sd">    - items is in ascending order</span>
<span class="sd">    - item is comparable to all members of items</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_slice</span><span class="p">(</span><span class="n">start</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">end</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return True if and only if item is in slice items[start:end].</span>

<span class="sd">        Preconditions: 0 &lt;= start &lt;= end &lt;= len(items)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Searching&#39;, item, &#39;in&#39;, items[start:end])</span>
        <span class="k">if</span> <span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">middle</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">middle_item</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">middle_item</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="n">middle_item</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">in_slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">middle</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">in_slice</span><span class="p">(</span><span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">in_slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Here are some tests. You may wish to add more, e.g. with all items the same.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span><span class="w"> </span><span class="nn">algoesup</span><span class="w"> </span><span class="kn">import</span> <span class="n">test</span>

<span class="n">has_tests</span> <span class="o">=</span> <span class="p">[</span>
    <span class="c1"># case,                 items,  item,   has?</span>
    <span class="p">(</span><span class="s1">&#39;empty list&#39;</span><span class="p">,</span>          <span class="p">[],</span>     <span class="mi">1</span><span class="p">,</span>      <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is before 1 item&#39;</span><span class="p">,</span>    <span class="p">[</span><span class="mi">2</span><span class="p">],</span>    <span class="mi">1</span><span class="p">,</span>      <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is the 1 item&#39;</span><span class="p">,</span>       <span class="p">[</span><span class="mi">1</span><span class="p">],</span>    <span class="mi">1</span><span class="p">,</span>      <span class="kc">True</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is after 1 item&#39;</span><span class="p">,</span>     <span class="p">[</span><span class="mi">2</span><span class="p">],</span>    <span class="mi">3</span><span class="p">,</span>      <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is before 2 items&#39;</span><span class="p">,</span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span>      <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is between 2 items&#39;</span><span class="p">,</span>  <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">3</span><span class="p">,</span>      <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is after 2 items&#39;</span><span class="p">,</span>    <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">5</span><span class="p">,</span>      <span class="kc">False</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is 1st of 2 items&#39;</span><span class="p">,</span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">2</span><span class="p">,</span>      <span class="kc">True</span><span class="p">),</span>
    <span class="p">(</span><span class="s1">&#39;is 2nd of 2 items&#39;</span><span class="p">,</span>   <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">4</span><span class="p">,</span>      <span class="kc">True</span><span class="p">),</span>
<span class="p">]</span>

<span class="n">test</span><span class="p">(</span><span class="n">has</span><span class="p">,</span> <span class="n">has_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Testing has...
Tests finished: 9 passed (100%), 0 failed.
</pre></div></div>
</div>
<section id="Exercise-13.4.2">
<h3>Exercise 13.4.2<a class="headerlink" href="#Exercise-13.4.2" title="Link to this heading"></a></h3>
<p>Write the recursive definition of T for this algorithm’s worst case and determine the complexity by checking if the definition has a form seen before.</p>
<p><a class="reference internal" href="../31_Hints/Hints_13_4_02.html"><span class="doc">Hint</span></a> <a class="reference internal" href="../32_Answers/Answers_13_4_02.html"><span class="doc">Answer</span></a></p>
<p>You saw brute-force searches that don’t generate symmetric candidates in order to shrink the search space by half or better. For example, for the <a class="reference internal" href="../11_Search/11_2_factorisation.html#Sort-candidates"><span class="std std-ref">factorisation problem</span></a> we decreased the upper limit of the search space from <em>n</em> to <span class="math notranslate nohighlight">\(\sqrt{n}\)</span>. Binary search prunes the search space by half after <em>each</em> test, not just at the start of the algorithm. This makes a tremendous difference, as you’ve seen for the <a class="reference internal" href="13_2_decrease_half.html#Code-and-performance"><span class="std std-ref">exponentiation
operation</span></a>.</p>
</section>
</section>
<section id="Iterative">
<h2><span class="section-number">13.4.3. </span>Iterative<a class="headerlink" href="#Iterative" title="Link to this heading"></a></h2>
<p>The recursive algorithm is tail recursive, so an iterative version is due. It’s not strictly necessary because a recursive decrease-by-half function doesn’t exceed the call stack limit: processing one billion items requires at most <span class="math notranslate nohighlight">\(\log_2\)</span> 10⁹ ≈ 30 calls.</p>
<p>An iterative implementation has the same complexity but is marginally faster, as it avoids the constant-time function call overheads. It simply reduces the slice until it’s empty or the item is found. I don’t repeat the docstring.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">has_iterative</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="nb">list</span><span class="p">,</span> <span class="n">item</span><span class="p">:</span> <span class="nb">object</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>  <span class="c1"># noqa: D103</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">end</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">items</span><span class="p">)</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">:</span>  <span class="c1"># alternative: while start != end</span>
        <span class="n">middle</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="n">middle_item</span> <span class="o">=</span> <span class="n">items</span><span class="p">[</span><span class="n">middle</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">middle_item</span> <span class="o">==</span> <span class="n">item</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">item</span> <span class="o">&lt;</span> <span class="n">middle_item</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">middle</span>  <span class="c1"># search left half [start:middle]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># search right half [middle+1:end]</span>
    <span class="k">return</span> <span class="kc">False</span>


<span class="n">test</span><span class="p">(</span><span class="n">has_iterative</span><span class="p">,</span> <span class="n">has_tests</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Testing has_iterative...
Tests finished: 9 passed (100%), 0 failed.
</pre></div></div>
</div>
<p>Let’s compare the run-times for a worst case: the item isn’t in the sequence.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># If running this cell in the VCE leads to a crash, set `items` to fewer zeros.</span>
<span class="n">items</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">1_000_000_000</span>  <span class="c1"># a billion zeros</span>

<span class="o">%</span><span class="k">timeit</span> -r 5 has(items, 1)
<span class="o">%</span><span class="k">timeit</span> -r 5 has_iterative(items, 1)
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
3.08 μs ± 3.09 ns per loop (mean ± std. dev. of 5 runs, 100,000 loops each)
2.27 μs ± 45.3 ns per loop (mean ± std. dev. of 5 runs, 100,000 loops each)
</pre></div></div>
</div>
<p>Doing 30 iterations instead of 30 recursive calls only saves a few microseconds. Recursion, even without tail optimisation, adds a very small overhead. The efficiency of a search algorithm depends on how it prunes the search space, not on whether it’s recursive or iterative.</p>
<div class="admonition warning">
<p><strong>Note:</strong> Recursion isn’t inherently inefficient.</p>
</div>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="13_3_variable_decrease.html" class="btn btn-neutral float-left" title="13.3. Variable decrease" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="13_5_variants.html" class="btn btn-neutral float-right" title="13.5. Binary search variants" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020–2025 The Open University.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(false);
      });
  </script> 

</body>
</html>