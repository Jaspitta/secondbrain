# þÿTopic 10   Context Switching: View as Single Page | OU Online

![rw-book-cover](https://readwise-assets.s3.amazonaws.com/media/reader/parsed_document_assets/291329529/3VpV1eB9cmTpq0siwtuUH8s_cHdYccQk0SomvUWArNM-cove_4sidGzC.png)

## Metadata
- Author: [[readwise.io]]
- Full Title: þÿTopic 10   Context Switching: View as Single Page | OU Online
- Category: #articles
- Summary: Context switching is the process by which an operating system switches between different processes, allowing it to manage multitasking on a single CPU core. When a process is temporarily blocked, such as during an I/O operation, the OS saves its state and chooses another process to run. This mechanism helps give the illusion that multiple programs are running at the same time, even though only one process can execute at any moment on a single core.
- URL: https://readwise.io/reader/document_raw_content/291329529

## Highlights
- there may be tens or hundreds of processes executing concurrently but typically only two to eight cores are available.
- For each process, the operating system maintains a record called a context block which contains relevant information about the process, such as which areas of memory are allocated to it. The context block also records the state
- whether it is running or not
- only a single process can be running (on a single CPU core). The operating system will mark this process as running in its context block
- a process may initiate an I/O operation.
- the operating system will suspend the process until the I/O operation completes. The suspended process is said to be blocked.
- n the I/O operation completes
- operating system could decide to change its state back to running immediately
- Alternatively, it could allow the currently running process to continue
- the operating system will mark the process that was formerly blocked as ready
- The operating system has to decide which of these ready processes to pick
- how can the operating system intervene and start its own instructions executing? Only if the operating system regains control of the processor can it carry out the operations required
- o write all application programs so that they periodically yield control back to the operating system
- This is a cooperative multitasking
- programmers may be tempted to gain extra performance for their application by breaking the rules
- d a way in which the operating system can always pre-empt an executing process
- pre-emptive multitasking.
- A hardware interrupt is a mechanism to do just this
- e the processor to interrupt its current execution and jump to an interrupt service routine.
- generated by a hardware timer device
- An OS will set a timer to generate regular interrupts
- part of the operating system kernel
- All mainstream OSs are pre-emptive so that buggy or malicious code can never prevent the OS regaining control
- The previous activity suggests that other states and transitions might be needed, and an operating system may indeed have more process states than have been described here.
- Each time a process changes state, the OS can perform a context switch to another process, using its scheduler to choose which process
- s events that cause changes of state
- system call, for example a process initiating I/O or going to sleep
- hardware interrupt,
- Changing which process is currently executing is known as context switching;
- when, what and how
- first is to ensure that the OS itself is executing
- second is what information about a process must be saved
- s how to cleanly switch the processor
- state transitions only happen during a system call or an interrupt, and that these are handled by the operating system
- context switches only occur in either a system call or an interrupt handler, and that both cases are handled by the operating system kernel.
- used to decide which process to run next, and to make sure that the operating system can restore each process
- information about each process is recorded in a context block
- The process identifier (PID),
- the location of the process’s return stack is recorded by the processor stack pointer register
- a context block in main memory for every process
- updated each time the operating system suspends a process
- Whenever the operating system changes the state of a process to running, the processor begins to execute instructions in the context of the new process. Its registers will have different contents, the memory being used will be different, different files may be open, and so on.
- The operating system has performed a context switch by selecting a new process to run.
- the current context, including the processor registers, is saved in the current context block
- the state of this process is changed from running to blocked
- the scheduler decides which process should run next
- the state of the newly chosen process is changed from ready to running
- the context of the new process, including processor registers, is loaded from its context block.
- Since the process context includes the processor instruction pointer (IP) that controls what instruction is executed next, at the end of a context switch execution will resume in the newly chosen process, not the process that was running before the switch.
- When an interrupt occurs, the processor automatically saves the IP as the return address. The interrupt handler ends with a return instruction that restores this saved value into the IP so that execution jumps to the correct return address. When an interrupt does result in a context switch, the OS substitutes a different return address so that the return instruction jumps to a different process.
- A timer interrupt occurs and I will assume that process A has exceeded its quantum
- the context of process A is saved and replaced by that for B
- includes both the processor registers and the memory space in use. This includes the stack:
- When the timer interrupt occurred, the processor saved the instruction pointer of process A on to its stack, expecting to resume execution there after the return instruction
- because the context has changed, the stack is now that for process B
- When the processor executes the return, the new IP will be in process B and executing will continue in process B.
- since both the syscall instruction and a hardware interrupt save the IP in the same way, the context switch works identically.
- For many purposes, processes and threads are treated equally even though threads share memory.
- this sharing means that a context switch between the threads of one program is easier and quicker
- Threads are therefore sometimes called ‘lightweight processes’
- multiple concurrent processes and threads can also be used to good effect to collaborate on tasks,
- there are some issues that arise when considering collaborating processes.
- One is whether memory can be shared between processes
- An OS normally provides separate memory space for each full process for privacy and security, so additional features must be provided
- Threads however do share memory,
- an OS can provide other mechanisms to allow separate processes to communicate
- for example by passing messages from one process to another via the operating system.
- problems that can arise when more than one process operates on the same data at the same time
- concurrency means that the lifetime of the processes overlap.
- context switches mean that instructions from both processes become interleaved.
- a race condition because the outcome depends on how fast each process executes and which wins the race to update the shared data.
- a shared resource
- particular portions of the code, known as critical regions,
- execute critical regions for a shared resource.
- , timing m
- Rarity is no defence: code must be written to operate correctly in all circumstances
- A semaphore can lock a critical region so that only a single process can execute at a time
- the semaphore – which can be used to deal with concurrency issues.
- One key use of a semaphore is to control access to a critical region of code
- , it will prevent other processes from entering a critical region if another process is already executing a critical region.
- A semaphore for mutual exclusion can also be thought of as a simple integer value
- There are also system calls needed to create and destroy semaphores
- A semaphore used in this way for mutual exclusion is often referred to as a mutex
- originally introduced by the Dutch computer scientist E.J. Dijkstra (1965)
- Semaphores can be used for other purposes besides mutual exclusion if the initial value is given a value greater than 1
- , if we need to control access to a buffer of say 10 items
- A thread depositing an item in the buffer should call sem_wait. Each time a thread calls sem_wait, the count is decremented; once the count reaches 0 any other thread calling sem_wait will be blocked
- a process can experience starvation, where it perpetually waits for a resource that other processes are using continually, and deadlock, where two or more processes end up waiting for each other so that none can complete
