# þÿTopic 7   Input/Output: View as Single Page | OU Online

![rw-book-cover](https://readwise-assets.s3.amazonaws.com/media/reader/parsed_document_assets/288416376/wdL2rpH_iQRY1mIygzFR1H7FO-khDuJ3K6ZBg6UHTaI-cove_KER23gg.png)

## Metadata
- Author: [[readwise.io]]
- Full Title: þÿTopic 7   Input/Output: View as Single Page | OU Online
- Category: #articles
- Summary: This text explains how an operating system manages input/output (I/O) devices through an I/O module. It covers the structure of the I/O module, data transfer techniques, and the importance of buffering and caching to improve performance. The OS interacts with hardware using device drivers and I/O registers, ensuring efficient communication between the system and various devices.

## Highlights
- there is some overlap between the I/O module and the file system module. This is because, at the lowest level, reading and writing files requires I/O operations on secondary storage devices.
- The lowest level of the I/O module is organised as device drivers
- Device drivers connect directly to the hardware interface and are responsible for data transfers
- Higher- level layers deal with general features which can be implemented in a device-independent manner
- I/O devices vary greatly,
- , the operating system is designed to provide a framework into which device drivers can be ‘plugged’.
- driver is written specifically for each I/O device
- it has to support a specific software interface;
- This interface will include operations such as read and write
- . As long as its device driver correctly supports these operations, a new I/O device can be installed
- a device driver itself may be layered. It might have generic components provided by the OS that apply to a whole class of devices (for example, all disk drives), meaning relatively few parts specific
- Device drivers run in kernel mode with access to critical operating system data;
- By supplying more of the I/O module software themselves, OS implementors can hope to avoid these problems and achieve better reliability for the end-user.
- A bus is an interface to which several devices can be connected at the same time; this requires standardised data transfer protocols and a way of identifying different devices.
- the OS can provide generic USB drivers to handle classes of device such as keyboards, mice or secondary storage,
- Bus-connected devices need to identify themselves
- That description includes what class of device it is
- host computer and peripheral device negotiate data rates and, if necessary, a specialised driver is located and loaded into the kernel.
- Peripherals that connect through a bus therefore need their own internal processor and memory to handle these negotiations
- a bus such as USB, as well being used to connect devices, must also be thought of as an I/O device in its own right. Hardware is required to implement and control the bus;
- An I/O interface is required between the OS and the bus controller.
- There has been a trend to increased integration in computer design
- many of the system’s functions are handled within a single large chip
- A computer system can have many I/O devices. Some of these are clearly peripheral
- some appear more integrated, such as the touchscreen
- , they are all treated as I/O devices by the OS.
- The OS maintains tables which link each device to the computing resources it needs, such as the device driver and the I/O registers
- internally the OS relies on a numbering system
- Devices receive a major and a minor device number
- , but two devices of the same type share a major number
- Devices with the same major number can use the same device driver code.
- One major classification used by most OSs is into character and block devices
- Keyboards generate a stream of characters
- secondary storage such as disk drives, always transfer data in large fixed-size blocks.
- The Linux /sys, /dev and /proc pseudo file systems provide an interface to aspects of the operating system. Each entry here is not a conventional file, but links to information that is stored in the OS’s internal tables.
- an OS is just a computer program consisting of machine instructions
- Many of these instructions will load and store values in the main RAM memory, but some can be used to read/write binary values from/to hardware locations called I/O registers instead.
- provide the lowest-level interface to hardware,
- . This technique is called port-addressed I/O
- Some processors have special I/O instructions (for example in and out) to read/write registers, called ports
- Processors also use memory-mapped I/O. This means that the I/O registers replace RAM at certain addresses in memory. They can be accessed using the same instructions normally used to read or write values in RAM,
- Many devices also generate interrupt signals, and the service routines that handle them are located in the device driver.
- Data transfers are carried out by device drivers
- There are three techniques used to control the transfer of data
- One method is for the processor to poll the device until an I/O event occurs. This will be shown by a change in the value of the status register, say from busy to ready.
- useful technique in simple embedded systems, but there are problems
- t it uses busy waiting: the processor is tied up until I/O is complete.
- In a multitasking system it would be better for a context switch to occur so that another process can be executed
- the I/O hardware signals an interrupt whenever an I/O operation is completed;
- the interrupt signal is detected by the processor, which jumps to an interrupt service routine (ISR). The ISR handles the interrupt and then returns
- There is no busy waiting:
- In an interrupt-driven system, an interrupt occurs for each I/O operation, that is for each byte that is sent or received.
- A direct memory access (DMA) controller is a device that can transfer data directly between I/O devices and main memory without involving the processor.
- DMA controller uses memory directly
- The DMA controller itself is a device with its own I/O registers that the operating system can use to specify what transfer is to be made.
- registers hold the starting address where the data is to be read/written in main memory and a count of how many bytes are to be transferred.
- When the DMA controller has completed transferring all the data requested, it issues an interrupt. DMA is particularly useful for devices such as disk drives which transfer data in blocks
- DMA transfer is efficient since the processor can continue to execute instructions in parallel
- . Achieving hardware independence is of course a goal of all operating systems as a whole, but it also applies inside the OS.
- . Buffering and caching by the I/O module can be done for any device, so the software for handling buffering and caching will be found at the higher-level
- a process makes a system call to input or output some data
- The process must be blocked until input arrives
- a key is pressed which generates an interrupt
- ISR (interrupt service routine) reads the data and stores it somewhere
- operating system can now mark the blocked process as ready so that after a context switch it can continue to execute
- the process will return from the original system call it made with the input character that was stored by the ISR
- For an output operation,
- An interrupt is signalled when the previous output operation completes; this allows the ISR to start the new output operation by writing the data to the data register.
- The calling process can now be marked ready and will continue
- an interrupt occurs for each I/O operation
- the important point is that an I/O operation may be satisfied immediately with a buffer so there is no need to block the calling process. A process is only blocked if an output buffer is full or an input buffer is empty.
- The operating system allows a user process to read/write single bytes or chunks of whatever size is convenient; these demands can be satisfied from the buffer.
- Only when the buffer is full (for output) or empty (for input) does the operating system start an I/O operation
- no context switch occurs unless an I/O operation is needed.
- Buffering here decouples the speed of the user process and the device.
- user process and device don’t have to wait for each other
- changes that don’t fill the buffer could be lost when a process ends
- the user process must call specific operating system services to open and close a device before and after use; the close operation is responsible for writing out incomplete buffers
- Main memory can also be used as a cache for I/O devices, especially for secondary storage such as a disk
- A buffer may be holding the only copy of data, for example if a user process has written some data but the I/O operation to write it out to secondary storage is not yet complete. A cache, on the other hand, always contains a copy of data which is stored elsewhere.
- the operating system can allocate chunks of memory as a buffer and then retain them as a cache
- If the first block is required again, then it can be taken from the cache
- The OS may also implement read-ahead caching: if a process reads a particular block from disk, then the OS can also start reading in the next
- few blocks into cache on the assumption that they may also be needed.
- Performance of a system can therefore be improved by using plenty of main memory as a disk cache. However, this means less main memory can be used by processes, which could result in more virtual memory pages being swapped out to disk, reducing performance
- There are two important aspects to a secondary storage system: the physical hardware device, and the way in which data is organised on it.
- The logical organisation of data is through files and directories; this is the responsibility of the file system module,
- The hardware can be treated like other I/O devices a
- All secondary storage systems are block devices
- all read and write operations transfer a large block of data.
- The size of a block may also vary on different devices, but an OS typically simplifies things by working with a standard-size block. The OS can rely on the device driver to convert to the particular size of block (or sector or page) that the device uses internally.
- all secondary storage devices can be seen as simply containing a large number of blocks, numbered 0, 1, 2, 3, … u
