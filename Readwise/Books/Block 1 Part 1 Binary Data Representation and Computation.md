# Block 1 Part 1 [[Binary]] Data Representation and Computation

![rw-book-cover](https://readwise-assets.s3.amazonaws.com/media/reader/parsed_document_assets/151311071/ohsBMMKwcl-B-TN1lFoICDlzc29HDYr2hEfXkE_Pdrs-cove_d57mNFU.jpg)

## Metadata
- Author: [[The Open University]]
- Full Title: Block 1 Part 1 [[Binary]] Data Representation and Computation
- Category: #books
- Summary: The document explains how [[binary]] arithmetic is used to represent integers and text in computers, detailing how operations such as addition and comparisons are carried out using [[logic operations]] and circuits. It provides examples of converting numbers between [[binary]] and decimal notations, showing how various [[encoding]] methods allow for the representation of positive and negative integers. The text also introduces the concept of two's complement notation for [[encoding]] integers and discusses building [[logic circuits]] to add [[binary]] numbers efficiently.

## Highlights
### Introduction
- able to compare some of the different [[binary]] representations of data and reason about their efficiency ([View Highlight](https://read.readwise.io/read/01hrva10hmxy8f067fvn5rbwee))
- why [[binary]] is used in modern computers and how data is physically represented using [[voltages]] ([View Highlight](https://read.readwise.io/read/01hrvaag5pdykjvcxb1121g2cy))
### 1.1 Representing integers and text in [[binary]]
#### 1.1.1 Why [[binary]]?
- many examples of [[binary]] information systems – that is, systems where data is represented using just two symbols ([View Highlight](https://read.readwise.io/read/01hrvad2220y9v08q8mmc5g61w))
- [[Morse code]] is one example ([View Highlight](https://read.readwise.io/read/01hrvada8qn7bj4t8jh4gt8e7z))
- Ships use a system called the [[International Code of Signals]] ([View Highlight](https://read.readwise.io/read/01hrvakcc9pap6nnvmj6pr5c30))
- uses a set of flags where either a standalone flag has a specific meaning, or a flag represents a particular letter ([View Highlight](https://read.readwise.io/read/01hrvakpnqyz3thcgnfcdhwdhf))
- it is important that the symbols can be distinguished ([View Highlight](https://read.readwise.io/read/01hrvaw23345qqr43j9bp8dvmp))
- in a [[binary]] system there are only two symbols, so it is generally easier to make them different enough to be distinguishable ([View Highlight](https://read.readwise.io/read/01hrvav5k8zfazkgjrke9q5twm))
- [[Morse code]] specifies that a dash should be three times as long as a dot ([View Highlight](https://read.readwise.io/read/01hrvava5jnmjbw8m1fpr67fpv))
- Early train signalling systems used the [[*lower quadrant signal*]] ([View Highlight](https://read.readwise.io/read/01hrvazz3vah6caxxacatjevzk))
- snow accumulating on a signal ([View Highlight](https://read.readwise.io/read/01hrvb07d58ytnefcmsfc01ahz))
- the arm did not move ([View Highlight](https://read.readwise.io/read/01hrvb0d60se7jm17rnjpgywe4))
- the famous train The [[Flying Scotsman]] crashed into a coal train ([View Highlight](https://read.readwise.io/read/01hrvb0pnzcezj9fqthxxdy138))
- Lower quadrant signals were changed to [[*upper quadrant signals*]] ([View Highlight](https://read.readwise.io/read/01hrvb0waxxr8etm7kjc83jy22))
##### [[Binary]] representation systems in computers
- [[ENIAC]] ([[Electronic Numerical Integrator and Computer]]), tried to represent data using our usual base-10 system. So 0 volts was used to represent the digit 0, 1 volt to represent the digit 1, and so on ([View Highlight](https://read.readwise.io/read/01hrvb4ssv0jds5z1z3hjmzse8))
- problems: voltage is not steady in a circuit ([View Highlight](https://read.readwise.io/read/01hrvb53mfhwkna33z5mh9s7zk))
- a lot of circuitry was needed just in order to distinguish between the different voltages ([View Highlight](https://read.readwise.io/read/01hrvb5n6gr6ywa5487zmzb204))
- advantage of representing data in [[binary]] is that only two ranges of voltage need to be detected ([View Highlight](https://read.readwise.io/read/01hrvb6v6kh6xh5p7k02mr3df4))
- The actual voltage values are defined in the specification of the electronic [[transistors]] used in a processor ([View Highlight](https://read.readwise.io/read/01hrvb84hkxssre9zyv63mhxaj))
- 0 and 1.3 V (‘low’ voltages) ([View Highlight](https://read.readwise.io/read/01hrvb8fn9gt7kwwgyj0q3kyyd))
- 1.7 V (‘high’ voltages) ([View Highlight](https://read.readwise.io/read/01hrvb8rhy8gjc7aw90rzdmtrg))
- Once [[binary]] symbols have been decided upon ([View Highlight](https://read.readwise.io/read/01hrwp8swqfjvkekze9h9w0pv7))
- individual symbols, or combinations of the symbols, need to be allocated a meaning ([View Highlight](https://read.readwise.io/read/01hrwp907591ahg7jvkaj301hh))
- The process of combining the symbols to represent data is called [[encoding]] ([View Highlight](https://read.readwise.io/read/01hrwp8nbrr8m0cmx7zdbrpp7b))
- [[encoding]] is not just done at random. The most frequent letters, such as E and T, have patterns that can be transmitted quickly ([View Highlight](https://read.readwise.io/read/01hrwpdp5qsfwpawya2rcj0hek))
#### 1.1.2 A quick revision of [[binary]]
- [[place-value notation]] ([View Highlight](https://read.readwise.io/read/01hrwx1xanpnc33bjjy25g8s6y))
- same symbol is used to represent different values, depending on its position ([View Highlight](https://read.readwise.io/read/01hrwx293m4ejzycts9qfcd0xw))
##### The decimal number system
- each position differs from the next by a power of 10 ([View Highlight](https://read.readwise.io/read/01hrwx6zfyksg4d4xw4jdqepqm))
##### The [[binary]] number system
- [[place-value system]] with two symbols, 1 and 0. In [[binary]] each place value is a power of 2 ([View Highlight](https://read.readwise.io/read/01hrwx8yhvzp6cmqf202pnbk7j))
##### [[Converting numbers]] from [[binary to decimal]] notation
- we put the number in the table and add up the values of each place value. ([View Highlight](https://read.readwise.io/read/01hrwxb9zp5mxp0vf42eznewde))
- If two or more number systems are being considered, we use a subscript to show which representation is being used. So, for example, we can write 10012 = 910. ([View Highlight](https://read.readwise.io/read/01hrwxehmnm8aew6afdp5r24t9))
- in the context of [[computing]] ([View Highlight](https://read.readwise.io/read/01hrwxf087a5xm6vs23y4ca238))
- each symbol being stored in a [[bit]] ([View Highlight](https://read.readwise.io/read/01hrwxf712f7cppejd8zg6fz1s))
##### [[Converting numbers]] from [[decimal to binary]] notation
- identify the largest power of two that divides into the number ([View Highlight](https://read.readwise.io/read/01hrwxh6ngx06w8ddnt5ptwxgd))
- put a 1 into that column in the place-value table ([View Highlight](https://read.readwise.io/read/01hrwxhb2dwzmtjx23cy9v01gh))
- calculate the remainder of the division and repeat the process ([View Highlight](https://read.readwise.io/read/01hrwxhkqgs8dnrnt50yre3xd7))
- If the level of noise is too high, there is a small chance that the voltage might be pushed into the gap or even into the wrong range. This is called a [[bit error]] ([View Highlight](https://read.readwise.io/read/01hrw8xcg160tnp4tsgye4w52b))
- one way of avoiding this would be to increase the gap ([View Highlight](https://read.readwise.io/read/01hrw902tv5x8v60pfpy0yxbv5))
- a higher voltage means more power ([View Highlight](https://read.readwise.io/read/01hrw90bpzgfafa5140m3exreh))
- dissipated as [[heat energy]] ([View Highlight](https://read.readwise.io/read/01hrw90gt7nmjzaffadpx6nsh9))
- reducing heat output in the circuits is important ([View Highlight](https://read.readwise.io/read/01hrw90r88jqqgpyynqjn8pybb))
##### Putting the symbols together
#### 1.1.3 Representing integers in [[binary]]
##### [[Unsigned integers]]
- an integer that is greater than or equal to zero ([View Highlight](https://read.readwise.io/read/01hrwy2kc2dft5x8ry0y1wg69r))
- a counter counting upwards ([View Highlight](https://read.readwise.io/read/01hrwy2z5vw8yb8j68bjt6g85f))
- number of unsigned decimal ([View Highlight](https://read.readwise.io/read/01hrwy3ex8qc9ka879am50eyvp))
- number of bits we have available ([View Highlight](https://read.readwise.io/read/01hrwy3p0910vz4vj73cbpf7hs))
- 3 bits available, we can represent 23 = 8 values ([View Highlight](https://read.readwise.io/read/01hrwy3t2kgfmqprw711e11r0d))
- largest decimal ([View Highlight](https://read.readwise.io/read/01hrwy8d22d9ysffd6cd1kgj18))
- 23 – 1) because one of the 8 available codes has been used up to represent 0. ([View Highlight](https://read.readwise.io/read/01hrwy8n3vn7qtn54v14zj06s6))
- the greater the number of bits, the more integers that can be represented ([View Highlight](https://read.readwise.io/read/01hrwybgjfgvy30f76e7zqm6c6))
##### [[Adding unsigned integers]] in [[binary]] notation
- their [[binary]] values can just be added. ([View Highlight](https://read.readwise.io/read/01hrwygfjdgfwd6nexetsrwx84))
- use the same method as adding two [[decimal numbers]] ([View Highlight](https://read.readwise.io/read/01hrwygyfq3ssmh4tkf74hms6v))
- numbers are written one under the other ([View Highlight](https://read.readwise.io/read/01hrwyha4vrph38eejcd4gywcw))
- each column are added ([View Highlight](https://read.readwise.io/read/01hrwyhhwvjzk993em73teyy7m))
- carrying digits as necessary ([View Highlight](https://read.readwise.io/read/01hrwyhpnbfvae0d7qg2x763cq))
##### [[Sign-magnitude representation]]
- use the first bit to indicate whether the integer is positive or negative and the remaining bits to represent the size ([View Highlight](https://read.readwise.io/read/01hrwyqtz01n3eca4wtkmmbjgw))
- There are two different [[encodings]] for 0: +0 and[[ –0]]. ([View Highlight](https://read.readwise.io/read/01hrwyxsw96f1bhpfgz2enea13))
- 2*n* available [[encoding]] ([View Highlight](https://read.readwise.io/read/01hrwz40hrfvjt7ec71mah4135))
- Half of them – that is, 2*n*/2 – will be used to represent 0 and positive integers, and the other half will be used to represent −0 and negative integers ([View Highlight](https://read.readwise.io/read/01hrwz4bwgpk8285m2c94k4wxn))
- largest positive integer that can be represented will be 2*n*/2 – 1 ([View Highlight](https://read.readwise.io/read/01hrwz4mxv108bdk0twr744rv0))
##### Addition of signed integers in the sign-magnitude representation.
- more complicated than adding unsigned integers. ([View Highlight](https://read.readwise.io/read/01hrwzbrj8yr14vjw96tajv32k))
- If both of the numbers are negative, or both of the numbers are positive, ignore the signs and add ([View Highlight](https://read.readwise.io/read/01hrwzckg81zjb29xrs24nz34b))
- If one number is positive and the other negative, ignore the signs and subtract the smaller number from the larger number ([View Highlight](https://read.readwise.io/read/01hrwzd83y77rq7qyvyz3467rv))
#### 1.1.4 The [[two’s complement]] representation of integers
- A different way of [[encoding]] both positive and negative integers is to move a block of half the available codes ‘backwards’ to represent negative integers ([View Highlight](https://read.readwise.io/read/01hrwzv976nrabms475hpyr141))
- [[two’s complement]] representation ([View Highlight](https://read.readwise.io/read/01hrwzvd95tanz9dmcz4xw1r0p))
- if the [[binary]] representation starts with a 0, it encodes a positive integer (or zero). If it starts with a 1, it encodes a negative integer ([View Highlight](https://read.readwise.io/read/01hrx0689mttrhwgrjfq33v11m))
- 23/2 = 4 – are allocated to 0 and positive integers ([View Highlight](https://read.readwise.io/read/01hrx06rsg8aj32veer8rxqp4d))
- the largest positive integer that can be represented is 3 ([View Highlight](https://read.readwise.io/read/01hrx072fzv6ck6daejx6wcwyx))
##### [[Arithmetic]] in [[two’s complement]]
- the [[two’s complement]] format is a much more convenient notation for a [[computer processor]] because the [[algorithm]] for adding two signed numbers in [[two’s complement]] is simpler ([View Highlight](https://read.readwise.io/read/01hrxvrsy5y3gskvax2h3xgd4a))
- 1. Add the [[binary]] numbers.
  2. Discard the leftmost bit if the answer exceeds the number of available bits. ([View Highlight](https://read.readwise.io/read/01hrxvss25rhn3gkxfd8zx3hqa))
- [[two’s complement]] allows integers, regardless of their signs, to be added with a much simpler and more efficient algorithm. As this is a very common and fundamental operation for a [[computer]], these [[efficiencies]] will pay off very quickly. ([View Highlight](https://read.readwise.io/read/01hrxvxk39zh78vzc67empxkv8))
- every subtraction can be rewritten as an addition – for example, 7 – 8 can be written as 7 + (–8) – the same [[algorithm]] can be used to do subtraction too ([View Highlight](https://read.readwise.io/read/01hrxw2ztdjafjjc9j8a3phsg0))
- multiplication is just repeated addition ([View Highlight](https://read.readwise.io/read/01hrxw34sg6xcv7preyq3j5p8j))
- division is repeated subtraction ([View Highlight](https://read.readwise.io/read/01hrxw38sbj03krp1vam1bvkr0))
- negative integer has to be [[converted]] only twice, at [[input]] and at [[output]] – a small price for the fact that all the ‘internal’ [[processing]] is more [[efficient]]. ([View Highlight](https://read.readwise.io/read/01hrxw4ax78fbf9w22zxdhtzjw))
#### 1.1.5 Representing [[text in binary]]
- modern systems for [[encoding]] text derive in part from [[ASCII]] ([View Highlight](https://read.readwise.io/read/01hrxwmaf62d4rw4da0zw9b8p8))
- 1963 ([View Highlight](https://read.readwise.io/read/01hrxwmfyeavmm434fyef1gm1v))
- encoded in 7 bits ([View Highlight](https://read.readwise.io/read/01hrxwr9w84a2f7b2kgryt76sc))
- [[computers]] based on multiples of 8 bits (or a [[byte]]) became more common, the [[encoding]] system became an 8-bit system, and so could be expanded to include more [[symbols]]. ([View Highlight](https://read.readwise.io/read/01hrxwrphrftp91hjmfptmejeq))
- choosing sequences of values for the characters of the alphabet and numerals that would make it easy for a[[ computer processor]] to perform common [[operations]] on them ([View Highlight](https://read.readwise.io/read/01hrxwsdzmwbpvhnka7bsp5a4e))
- [[ASCII]] values for corresponding [[upper-case]] and [[lower-case]] characters always differ by 32 ([View Highlight](https://read.readwise.io/read/01hrxwvnydfzwf630ht8y0r9zf))
- converting from upper case to lower case (a very common manipulation of text) is simply a matter of [[flipping the bit]] in the 32s (25) position ([View Highlight](https://read.readwise.io/read/01hrxwxf1tm3rke6rt95ars6fw))
- 0–9 are represented by [[ASCII]] values 48–57 ([View Highlight](https://read.readwise.io/read/01hrxx0p0a0trkq51m5w41qkzk))
- the rightmost 4 bits of these [[ASCII]] values (in blue in the table below) are the [[binary representations]] of [[unsigned integers]] 0–9 ([View Highlight](https://read.readwise.io/read/01hrxx152qtmphjcd808c5f41c))
- standard [[encoding]] system for characters has been[[ Unicode Transformation Format-8]] ([[UTF-8]]) which uses a variable number of [[bytes]] (up to 6 ([View Highlight](https://read.readwise.io/read/01hrxx3dn03ff52tdzrtz8tc59))
- backward compatibility, the original 127 [[ASCII]] codes are preserved in [[UTF-8]]. ([View Highlight](https://read.readwise.io/read/01hrxx3q4v4anj9hhmq25c9b8w))
##### Standards
- the best format for one [[processor]] was not necessarily the best for another ([View Highlight](https://read.readwise.io/read/01hry6szf4btteebyzszxs3gg4))
- need for data to be shared and processed across several different [[computers]] ([View Highlight](https://read.readwise.io/read/01hry6vw8s7hv4s1zp8nwf781w))
- [[formats]] also need to be revised periodically ([View Highlight](https://read.readwise.io/read/01hry6wyxt1qyjghvgx66q79xy))
- formalize a shared understanding of how each particular type of data is represented ([View Highlight](https://read.readwise.io/read/01hry6ycyvpw65yraj6ta1bm7j))
- in a document called a [[cloud computing definition standard]] ([View Highlight](https://read.readwise.io/read/01hry6ygqjkcvcnb11dtnzsmh8))
- standards need to be reviewed ([View Highlight](https://read.readwise.io/read/01hry6ywh4kfm69184f41j09zt))
- fit for purpose in a changing world. ([View Highlight](https://read.readwise.io/read/01hry6yyyzmhe3rcsxtw7axd0q))
- as much [[backward compatibility]] as possibl ([View Highlight](https://read.readwise.io/read/01hry7001vyaj5a8pv7m3ne993))
- In 1991–1992, the [[Unicode Consortium]] worked with the [[ISO]] to develop a new single unified standard ([View Highlight](https://read.readwise.io/read/01hry70zwspcxr3j2pse0rsxdq))
- includes 120,000 characters from 130 different languages ([View Highlight](https://read.readwise.io/read/01hry7199ttcj9ht9b5xcaqt06))
- three different formats ([View Highlight](https://read.readwise.io/read/01hry71e9ksn19q09afeshnvdp))
- whether 8, 16 or 32 bits are available. [[UTF-8]] is the 8-bit version ([View Highlight](https://read.readwise.io/read/01hry71rwp5911betcax2w7pww))
- compatible with the long-established [[ASCII]] standard ([View Highlight](https://read.readwise.io/read/01hry726rxnxphtbyfh1m0d1tx))
### 1.2 [[Decimal numbers]] and some limitations of [[binary representations]]
#### 1.2.1 [[Representing numbers]] with decimal points
- crucial that we can also represent and [[encode]] numbers with decimal points in [[binary]]. ([View Highlight](https://read.readwise.io/read/01hry9phzcmqmbdrer8evq84zv))
- decimal system the digits to the right of the decimal point (sometimes referred to as the fractional part of the number) represent powers of 1/10 ([View Highlight](https://read.readwise.io/read/01hry9q1qj0zd478nept7gzxjv))
- to the left of the decimal point, these stand for the usual placeholder powers of 10 ([View Highlight](https://read.readwise.io/read/01hry9r08cfrd3vw2cm7ehhbe1))
- similar idea for [[binary]] numbers ([View Highlight](https://read.readwise.io/read/01hry9w3p4p9qswpsg1b9ypp6y))
- the fractional part is composed of powers of 1/2 ([View Highlight](https://read.readwise.io/read/01hry9w6wwtbwpc4e12r2d2y51))
- Therefore 0.001012 is equal to 1/23 + 1/25 = 1/8 + 1/32 = 0.1562510. ([View Highlight](https://read.readwise.io/read/01hrya1h1xp3es3h7xvfa3804v))
- convert the whole-number part ([View Highlight](https://read.readwise.io/read/01hrya1xvzf7spt4y0q0f6hh3e))
- convert the fractional part ([View Highlight](https://read.readwise.io/read/01hrya21pj00cm95j80jcj5emh))
- add them together ([View Highlight](https://read.readwise.io/read/01hrya24bww5cmqtmkdj3sxsp8))
##### [[Floating-point numbers]] and [[scientific notation]]
- 2343.56. We could also write this as 23.4356 × 102
  or 0.234356 × 104 or 234356.0 × 10–2. ([View Highlight](https://read.readwise.io/read/01hrya69damg6vakztxzvgxmkz))
- The decimal point can ‘float’ to any position as long as the power of 10 is appropriate ([View Highlight](https://read.readwise.io/read/01hrya5fprxqdrd810pwzex711))
- numbers with decimal points are sometimes referred to as [[floating-point numbers]], or just [[floats]] for short. ([View Highlight](https://read.readwise.io/read/01hrya6t1d1skvpje6z20rv58v))
- [[Scientific notation]] is a special case of [[floating-point]] notation where there is a single non-zero digit between 1 and 9 ([View Highlight](https://read.readwise.io/read/01hryat92q777j11y455cg7k0c))
- 2343.56 can be represented in [[scientific notation]] as 2.34356 × 103 ([View Highlight](https://read.readwise.io/read/01hryatgbqf8drbnxgnm41g6tt))
- [[scientific notation]] has three distinct parts ([View Highlight](https://read.readwise.io/read/01hryav475r9c7j299y9hv6jt2))
- a sign ([View Highlight](https://read.readwise.io/read/01hryavffvk7j2y23kvkvfymgb))
- exponent ([View Highlight](https://read.readwise.io/read/01hryay8vrq54t85rxy9f34k79))
- a [[mantissa]] ([View Highlight](https://read.readwise.io/read/01hryavchrb4h8q9x35eam7x8a))
##### [[Scientific notation]] for [[binary]] numbers
- we have powers of 2 (rather than powers of 10) and the [[mantissa]] always starts with a 1, followed by a decimal point. ([View Highlight](https://read.readwise.io/read/01hryb55fn8jgf74eqehbhg01k))
- –10101.1 in [[binary]] notation can be written as –1.01011 × 24 ([View Highlight](https://read.readwise.io/read/01hryb5ecqhfta5hn1xzgedg14))
##### Representing [[floats]] in a [[computer]]
- represented in [[binary scientific notation]] ([View Highlight](https://read.readwise.io/read/01hrybwbdb5weg6dmqrqdqt2fd))
- float is stored in 4 [[bytes]] ([View Highlight](https://read.readwise.io/read/01hrybwz1846nj79ft5t3kv4ec))
- The sign of the number is stored in the leftmost bit ([View Highlight](https://read.readwise.io/read/01hrybx72hhptt8k1vemqf6jqm))
- exponent is stored in the next 8 bits ([View Highlight](https://read.readwise.io/read/01hrybxbfbtftxyfed9ah7y5mm))
- The fractional part of the [[mantissa]] is stored in the next 23 bits ([View Highlight](https://read.readwise.io/read/01hrym22zysw7327jbdk3k13af))
- leading 1 is not stored at all; because it is always 1, it can be ‘hardwired’ into the part of the processor that deals with [[floats]] ([View Highlight](https://read.readwise.io/read/01hrym2ng56jr1gmpm3kq146mk))
- many systems, there is also the facility for a [[floating-point]] representation called a [[double]] ([View Highlight](https://read.readwise.io/read/01hryme24zcx3b4drqynf0j66w))
- 11 bits are available for the exponent and 52 are available for the [[mantissa]] ([View Highlight](https://read.readwise.io/read/01hrymea5fhzgvm1kp38acw854))
- However, strange things can happen because of the[[ imprecise representations of binary numbers]]. For example, in order to round 2.675 to two decimal places, you would execute the statement: ([View Highlight](https://read.readwise.io/read/01hrywp8bb6gyyejvzb03r5t5t))
- `round(2.675, 2)`
  You would expect the answer to be 2.68; however, the value 2.67 is returned. The inconsistency occurs because the number 2.675 cannot be exactly represented in [[binary notation]] ([View Highlight](https://read.readwise.io/read/01hrywpj2r6jcb83459n458b10))
- standard for representing [[floating-point numbers]] is laid down in the [[IEEE Standard for Floating-Point Arithmetic]] ([[IEEE 754]]) ([View Highlight](https://read.readwise.io/read/01hrymh49pxwrfq95n31jeyzb0))
- including how numbers are rounded and how exceptions (such as dividing by 0) are handled. ([View Highlight](https://read.readwise.io/read/01hrymhqwdnphqmhrch8x5vpmn))
#### 1.2.2 Precision of [[floating-point]] representations
- Consider the decimal fraction 1/3 ([View Highlight](https://read.readwise.io/read/01hrympydrzsd54zydqbcs04a9))
- representation of [[floats]] in a [[computer]] might lead to unexpected results due to precision issues ([View Highlight](https://read.readwise.io/read/01hrywq8dcvq7ze711t9tx06v5))
- he precision of the decimal valu ([View Highlight](https://read.readwise.io/read/01hrymq6crm225m1q6v8wn8m00))
- ts closeness to the exact value ([View Highlight](https://read.readwise.io/read/01hrymq9b596rzsc2reybrbg8m))
- increases as the number of digits increase ([View Highlight](https://read.readwise.io/read/01hrymqbtaa612s1v4xwkmpa64))
- however many digits you write down, the result will not be exactly 1/3 ([View Highlight](https://read.readwise.io/read/01hrymqh5jxk5f8dxbaf75mcag))
- 0.110 cannot be represented exactly as a base 2 fraction ([View Highlight](https://read.readwise.io/read/01hrymr94y5x3t18mkq3f1m4rs))
- 1/10 is the infinitely repeating fraction ([View Highlight](https://read.readwise.io/read/01hrymrxpm2maerhzbm0bwghy0))
- always get an approximate ([View Highlight](https://read.readwise.io/read/01hryms7jr4ne53e8jew60269a))
- there are fractional numbers that cannot be represented exactly ([View Highlight](https://read.readwise.io/read/01hryn0ttt6ybdmfrkp79de242))
- 1994 it was discovered that early Intel Pentium processors had a bug that meant that they did float division incorrectly ([View Highlight](https://read.readwise.io/read/01hrywtnavs2mjja55yjcq2rwp))
#### 1.2.3 Precision problems of [[floating-point]] representations
- not a precision error ([View Highlight](https://read.readwise.io/read/01hrywtw3s24qkhtykgmb3cc2y))
- error in the logic of the [[floating-point]] unit of the processor itself ([View Highlight](https://read.readwise.io/read/01hrywv1w14gfj2wnmxkcnj4dc))
##### Precision problems in programming
- 53 bits required for the [[mantissa]] for a [[double]] ([View Highlight](https://read.readwise.io/read/01hryn9m987b5dgn6zj9mvb207))
- some calculations the value returned was incorrect beyond four digits ([View Highlight](https://read.readwise.io/read/01hrywvaeht6kz5pp9kx9bj7p7))
- when the decimal number 0.1 is stored in memory is the [[binary]] fraction:
  0.00011001100110011001100110011001100110011001100110011010 ([View Highlight](https://read.readwise.io/read/01hryn9yh32n25a5jej2vjh45w))
- , this [[binary]] number is equivalent to the decimal number:
  0.1000000000000000055511151231257827021181583404541015625. ([View Highlight](https://read.readwise.io/read/01hrynax4y6gbb5ptdx8fw5wsz))
- Intel finally recalled the faulty chip ([View Highlight](https://read.readwise.io/read/01hrywvqrgrjkp0snb78k37j4c))
#### 1.2.4 [[Underflow]] and [[overflow]]
##### [[Overflow]]
- all programming languages round [[floating-point]] values for display purposes ([View Highlight](https://read.readwise.io/read/01hrynbc1mnz779vecfqaf9zea))
- an [[arithmetic operation]] attempts to create a numeric value that is too large ([View Highlight](https://read.readwise.io/read/01hryx33t9c92bh5yr3xxcc4nx))
- may get some surprising results from [[floating-point]] operations ([View Highlight](https://read.readwise.io/read/01hrynbp8y7m5n25kpd5jgrfec))
- in many programming languages the most significant bit is dropped ([View Highlight](https://read.readwise.io/read/01hryx3q17c3badw1z7rh51ckz))
- adding 1 to 1111 in a 4-bit system is 0000 ([View Highlight](https://read.readwise.io/read/01hryx5782c0bcks29z8tmzstz))
- 0.1 + 0.1 + 0.1 == 0.3 ([View Highlight](https://read.readwise.io/read/01hrynh1pxw7zcmngc92nm4w9w))
- [[two’s complement]] ([View Highlight](https://read.readwise.io/read/01hryx5vq4f0r9893tdce9mqt0))
- largest integer that can be stored in four bits is 0111 ([View Highlight](https://read.readwise.io/read/01hryx63z29ndagw9q2vvnjtfg))
- this statement prints out `False` because the [[computer]] is not storing 0.1; it is instead storing:
  0.1000000000000000055511151231257827021181583404541015625. ([View Highlight](https://read.readwise.io/read/01hrynhayq6fkgzvkynw560e05))
- If you now ([View Highlight](https://read.readwise.io/read/01hryx6wgvxkdfs952432zb5tk))
- 7 + 1, the result is 1000 ([View Highlight](https://read.readwise.io/read/01hryx71vsz3gxytamge5kfjde))
- represents –8. ([View Highlight](https://read.readwise.io/read/01hryx6h0he07p5s87z5zqv8sq))
- **not** a Python problem – all programming languages will have limited precision ([View Highlight](https://read.readwise.io/read/01hrynhhtd4ggnmpfemg52fanh))
- An [[overflow]] of a float ([View Highlight](https://read.readwise.io/read/01hryx7gydahw36jmbajkyt2b4))
- integer exponent takes up more bits ([View Highlight](https://read.readwise.io/read/01hryx7pv30av3eybre348jcpd))
##### [[Underflow]]
- if the numeric value of the [[mantissa]] is too small to be stored in the available space ([View Highlight](https://read.readwise.io/read/01hryxr55bhvk28xrnwe73np0j))
- comparing [[floats]] for equality can lead to catastrophically misleading results ([View Highlight](https://read.readwise.io/read/01hrynkdawgw28e46y2qjq3zc2))
##### [[Rounding floating-point]] values
- if you want to [[round]] a value ([View Highlight](https://read.readwise.io/read/01hrynpz2s6rwxankr4tca9y8e))
- use the built in `round()` function ([View Highlight](https://read.readwise.io/read/01hrynq2e580wfbf1b9vzw1fg4))
- two parameters: the number to be rounded and the number of decimal places required. ([View Highlight](https://read.readwise.io/read/01hrynqasdqp4p978eqh901tk2))
- If the digit to the right of the required number of decimal places is a 5, then the digit to the left remains the same if it is an even number (or zero), and is rounded up if it is an odd number ([View Highlight](https://read.readwise.io/read/01hrynvaqxk6s79zty9ssep7ca))
- ‘[[bankers rounding]]’ ([View Highlight](https://read.readwise.io/read/01hryntbjw6j9n03xse8knr0sw))
- a value that ends in 5, on average half the time a value that ends in 5 is rounded up and half the time it is rounded down ([View Highlight](https://read.readwise.io/read/01hrynttex6n3mab5811h9wfvg))
- if many decimal values are added together, the rounding errors are minimised ([View Highlight](https://read.readwise.io/read/01hrynv1jcth8z4gasr4apqfmd))
- we can use [[binary encodings]] to represent numerical and textual data ([View Highlight](https://read.readwise.io/read/01hs85147jjgh8ffjg92y0yrvf))
- operations, including [[arithmetical operations]] ([View Highlight](https://read.readwise.io/read/01hs851r0rxz5pwyxzbqppbzd9))
- can be encoded as one or more [[logic operations]] ([View Highlight](https://read.readwise.io/read/01hs8521azjezvtaqs6hascpyb))
- These [[logic operations]] then act on the [[binary representations]] of the data. ([View Highlight](https://read.readwise.io/read/01hs8529a950zh7j0625fdz824))
- integers have to be encoded as [[binary representations]] ([View Highlight](https://read.readwise.io/read/01hs856jt4xgq4p0znbe52ze4r))
- the addition operator has to be encoded as a sequence of logical operations ([View Highlight](https://read.readwise.io/read/01hs856pvhnmtn2yk3pmc8pps8))
- [[logic operations]] are defined using a [[truth table]] ([View Highlight](https://read.readwise.io/read/01hs858e7c94a0exmr0jktvdtf))
- twentieth century ([View Highlight](https://read.readwise.io/read/01hs859vbnd75ppmabn0pqy083))
- capturing some of the work of the English mathematician [[George Boole]] ([View Highlight](https://read.readwise.io/read/01hs8596a0napbht75nc1cjz8w))
- A [[truth table]] for a logic operation lists all the possible combinations of input values ([View Highlight](https://read.readwise.io/read/01hs859n4bs69h0c1ejppgq6ys))
- input value must be either a 1 or a 0 ([View Highlight](https://read.readwise.io/read/01hs85agmrfp889sasqweamyd8))
- result of the operation must also always be a 1 or a 0 ([View Highlight](https://read.readwise.io/read/01hs85amezr90y73ypadrpkvne))
##### The [[NOT operation]]
- flip’ a single bit ([View Highlight](https://read.readwise.io/read/01hs85gtwq2w1apd7gngphxcty))
- if A is 1, we want the result to be 0, and if A is 0, we want the result to be 1 ([View Highlight](https://read.readwise.io/read/01hs85hb1zj8bxwdrspfnt0b02))
- 0s and 1s in a [[computer]] are in fact high and low voltages ([View Highlight](https://read.readwise.io/read/01hs85n1zn5xmje7pwxtp48ev8))
- we need to use electrical components ([View Highlight](https://read.readwise.io/read/01hs85nc726ag7g4yb1pwjs4j4))
- called [[logic gates]] ([View Highlight](https://read.readwise.io/read/01hs85nsyqy6hpdpnvtf91nfr5))
- combined in a [[logic circuit]] ([View Highlight](https://read.readwise.io/read/01hs85p5xz2pktwcy69rzqcex7))
##### The [[AND operation]]
- involve two input values ([View Highlight](https://read.readwise.io/read/01hs85yjxx5grj60wr6td2n2xv))
- [[truth table]] for two [[binary]] inputs, A and B, has more rows ([View Highlight](https://read.readwise.io/read/01hs85yzq3khav9jtjdmmz91dm))
- AND is analogous to ordinary multiplication (in fact, Boole originally used the symbol × for this logic operation ([View Highlight](https://read.readwise.io/read/01hs85zkzd72f3rkf1q4p1peq2))
- when applied to two inputs, only results in a 1 if A and B are both 1 ([View Highlight](https://read.readwise.io/read/01hs864dqmyep96k0xt13m0gaw))
- The [[OR operation]] ([View Highlight](https://read.readwise.io/read/01hs866wjjjx3yw5rv2tzyqffx))
- akin to decimal addition ([View Highlight](https://read.readwise.io/read/01hs8675awjctm3h1wdnef9dbv))
- Boole himself was not sure which was more appropriate, but he finally decided on 1 + 1 = 1. ([View Highlight](https://read.readwise.io/read/01hs868zyjgt0hrt2zfz975txg))
##### Summary of the NOT, AND and OR [[logic operations]]
- form the building blocks for all [[computer]] operations ([View Highlight](https://read.readwise.io/read/01hs86jdh7n7kwkecnw3m2k98r))
#### 1.3.2 Building [[logic circuits]]
- [[logic circuit]] with two inputs, A and B, that tests if B is greater than A ([View Highlight](https://read.readwise.io/read/01hs870e9nz3qvs27gqw8m1ng6))
- first step is to create a [[truth table]] ([View Highlight](https://read.readwise.io/read/01hs870yr7ytpnaabh48pztfe0))
- To translate this ([View Highlight](https://read.readwise.io/read/01hs8728hcvw0fh53add0atg9g))
- we follow this algorithm. ([View Highlight](https://read.readwise.io/read/01hs872fna1sxrg4z2z8xvynp0))
- Identify the row where the outcome (B > A) is 1. ([View Highlight](https://read.readwise.io/read/01hs872khntpx1j3ax0wkaqkxd))
- If input A is 1, write A; otherwise write NOT A ([View Highlight](https://read.readwise.io/read/01hs872y35e2pdq7dmc0qfzp4x))
- If input B is 1, write B; otherwise write NOT B ([View Highlight](https://read.readwise.io/read/01hs8734ybv728jjykngb2ghdv))
- Join these with an AND. ([View Highlight](https://read.readwise.io/read/01hs873ea3hwjzcz16864c1e2m))
- Here, the resulting logic expression NOT A AND B tells us that the [[logic circuit]] that is equivalent to this [[truth table]] ([View Highlight](https://read.readwise.io/read/01hs876vrz1v7qevb6yzz82wc1))
- can cause particular problems if the result is then used in multiplications or divisions ([View Highlight](https://read.readwise.io/read/01hs1pj9awa0pcer9zypbvyt27))
- unexpected 0s ([View Highlight](https://read.readwise.io/read/01hs1pjjz04fj0r0g92jsh2brn))
##### Dealing with [[overflows]] and [[underflows]]
- programming languages, such as Ada, proactively trigger an exception ([View Highlight](https://read.readwise.io/read/01hs1prdccc8gn543nm2677k92))
- Others, such as C and C++, do not specify what will happen ([View Highlight](https://read.readwise.io/read/01hs1prjxc43eb751db3ag1b5e))
- he programmer cannot rely on getting any warning ([View Highlight](https://read.readwise.io/read/01hs1ps6sq7qjzdfasmnjyzefp))
- other programming languages, automatically bumps up the amount of storage as necessary ([View Highlight](https://read.readwise.io/read/01hs1psjqbxe7pmhhwdv8htbnn))
- May 2015 ([View Highlight](https://read.readwise.io/read/01hs1pt8qz4tf4t6argzz258v4))
- Boeing 787 airplane engines switching themselves off mid-flight ([View Highlight](https://read.readwise.io/read/01hs1ptf2k4j2x2fe9b8q4235p))
- 4-byte memory location that held a ‘count’ of how long the engines had been fired up ([View Highlight](https://read.readwise.io/read/01hs1ptxwezkdt95gz7d09njj2))
- go into [[overflow]] sometime after the 248th day of continuous running ([View Highlight](https://read.readwise.io/read/01hs1pvb4f2fh909rsr0tr8q03))
- causing the engines to lose power while in flight. ([View Highlight](https://read.readwise.io/read/01hs1pvmc23ss5t367jjfe0bk2))
##### Avoiding [[underflow]] and [[overflow]] problems
- alternate arithmetic operations that increase or decrease intermediate results ([View Highlight](https://read.readwise.io/read/01hs1q1hywhhj6xvdnrscrfb7f))
- lternates multiplications and divisions as well as additions and subtractions ([View Highlight](https://read.readwise.io/read/01hs1q226mgww0d9g5qj277xce))
- languages also provide the maximum and minimum values that can be stored for different types of data as constants ([View Highlight](https://read.readwise.io/read/01hs1q2s8m9fj2782d000hr4ym))
### 1.3 Representing [[logic operations]] and [[logic circuits]]
#### 1.3.1 [[Logic operations]]
- adds two multi-digit integers ([View Highlight](https://read.readwise.io/read/01hs95qgv6t1yn33qdbtw8y389))
##### More complex [[logic circuits]]
- put them in two rows with the digits lined up in columns ([View Highlight](https://read.readwise.io/read/01hs95shk7xarg3qrwtqqcddx8))
- more than one row where the output is 1 ([View Highlight](https://read.readwise.io/read/01hs8zp8w8ch4t5j1eez3sae8y))
- adding the two rightmost digits together and putting the result below in the corresponding column ([View Highlight](https://read.readwise.io/read/01hs95sttjdjz62edwwa4sd4tt))
- logic expressions for each such row need to be combined with an OR operator ([View Highlight](https://read.readwise.io/read/01hs8zpfk9pzssw5qpzt7wmmh9))
- If the sum is more than one digit long, then we also have to carry a digit ([View Highlight](https://read.readwise.io/read/01hs95t1ngvyjffy6tezbsdfzm))
- test if A and B are equal ([View Highlight](https://read.readwise.io/read/01hs8zqyywm2f3qc2hzd8sqkqs))
- For these rows, if input A is 0, write NOT A, otherwise write A. If input B is 0, write NOT B, otherwise write B ([View Highlight](https://read.readwise.io/read/01hs8zx97gjfms7r9vxzp5w5pg))
- Join these with an AND ([View Highlight](https://read.readwise.io/read/01hs8zxjf3wmd7taed933zrp3y))
- the fourth possibility presents a problem because the result cannot be represented in 1 bit ([View Highlight](https://read.readwise.io/read/01hs95tcvpfwnk5m2tzmwkew7m))
- needs 2 bits because of the carry digit ([View Highlight](https://read.readwise.io/read/01hs95vkf01texh6qzvmgjwv8k))
- The logic expressions for each shaded row are now combined using an OR ([View Highlight](https://read.readwise.io/read/01hs8zxw1bqh6ypvk332qza0ct))
- that we have two outputs to keep track of: the sum of the two digits and a carry digit ([View Highlight](https://read.readwise.io/read/01hs95xc3zmbwcdratj1wtj2tb))
- The SUM [[truth table]] is logically equivalent to the logic expression:
  (NOT A AND B) OR (A AND NOT B) ([View Highlight](https://read.readwise.io/read/01hs95xn9f6cc2hd58sybpjnh0))
- The CARRY [[truth table]] is simply the AND operation:
  A AND B. ([View Highlight](https://read.readwise.io/read/01hs95yt3d297j75pcchg5bst3))
- Putting this together gives us the [[logic circuit]] shown in Figure 1.28, which is called a [[half adder]] ([View Highlight](https://read.readwise.io/read/01hs96aca4yhysnvm7a2cpbr81))
- The [[half adder]] is often represented in [[logic circuit]] diagrams ([View Highlight](https://read.readwise.io/read/01hs96cq9ddhrsxnnsq1s3hae8))
##### The [[1-bit full adder]]
- when we need to add together two [[binary]] numbers of more than one digit ([View Highlight](https://read.readwise.io/read/01hs96q356zyzb811f81fwh8cw))
##### Equivalent circuits
- there may be other [[logic circuits]] that have exactly the same outputs for the same inputs ([View Highlight](https://read.readwise.io/read/01hs9026et90531n3xgn96350s))
- we have to be able to add in any carry value from the previous calculation ([View Highlight](https://read.readwise.io/read/01hs96qewedj0jfk1r23yd412r))
- There could also be a carry out value to be added to the next column to the left. ([View Highlight](https://read.readwise.io/read/01hs96qvczjxkj8n5qm0n30wd7))
- label the carry in value as Cin and the carry out value as Cout ([View Highlight](https://read.readwise.io/read/01hs96s03zvgtkrjddg9hf6065))
- there are three inputs ([View Highlight](https://read.readwise.io/read/01hs96xhbcyfhb8wfnt20jvbz4))
- • the value of the digit from A
  • the value of the digit from B
  • Cin (a Carry in digit). ([View Highlight](https://read.readwise.io/read/01hs96xq39bf2qbxy66n4qkgre))
- there are two outputs ([View Highlight](https://read.readwise.io/read/01hs96xv0ztjqfy7ftyxfephdx))
- • the Sum of A + B + Cin
  • Cout (a Carry out digit) ([View Highlight](https://read.readwise.io/read/01hs96y19ht7ws76nryxqyxr4w))
- NOT (A OR B) is **equivalent** to NOT A AND NOT B. ([View Highlight](https://read.readwise.io/read/01hs90anc7pxdhsdsyppc3kjk3))
- NOT (A AND B) is equivalent to NOT A OR NOT B ([View Highlight](https://read.readwise.io/read/01hs90aq6vdntx6s9qax5qvqgs))
- [[De Morgan’s]] laws after the nineteenth-century British mathematician, Augustus De Morgan, who was a friend of [[George Boole]] ([View Highlight](https://read.readwise.io/read/01hs90ah4k63fzrvym2txw6ss0))
- in any [[logic circuit]] we can always replace ([View Highlight](https://read.readwise.io/read/01hs90b2f8cyc8148c8xemvfjz))
- OR gate with a combination of NOT gates and an AND gate ([View Highlight](https://read.readwise.io/read/01hs90b8trh0ec13cr1dkzf09s))
- AND gate with a combination of NOT gates and an OR gate. ([View Highlight](https://read.readwise.io/read/01hs90bct64sx23fp7qs294yhd))
- we can represent any logic expression and draw any [[logic circuit]] using just two types of logic gate ([View Highlight](https://read.readwise.io/read/01hs90by8p57wmzfz4r2sjsw1a))
- The [[logic circuit]] corresponding to this [[truth table]] called a **1-bit** full adder ([View Highlight](https://read.readwise.io/read/01hs970enmnw7fw3a3d55hzfzg))
- a [[1-bit full adder]] can be built out of two half adders ([View Highlight](https://read.readwise.io/read/01hs973f63whnt3n8dfhaeny9b))
#### 1.3.3 Building an adder
- The first [[half adder]] adds the digits A and B ([View Highlight](https://read.readwise.io/read/01hs9pn9mvypq0mt0db2zkpdra))
- the second [[half adder]] adds this intermediate Sum to the carry ([View Highlight](https://read.readwise.io/read/01hs9pngm2d0e6e2c0w5mgg5de))
- get the final Sum, S ([View Highlight](https://read.readwise.io/read/01hs9pnqrrhgwc4hx6q8x6svek))
- two ways of getting a final carry out value of 1 ([View Highlight](https://read.readwise.io/read/01hs9pnzt5jzb8x53cms3zv06c))
- from adding the inputs A and B ([View Highlight](https://read.readwise.io/read/01hs9pp309nyt737twng1kahxq))
- *or* it can come from adding A and B and Cin ([View Highlight](https://read.readwise.io/read/01hs9pp78yjdpceebeeh7spvp3))
##### Adding multiple [[binary]] values with multiple bits
- combine enough full adders ([View Highlight](https://read.readwise.io/read/01hs9pvezzm8y1kns200xhpq2f))
- make a circuit that will add two [[binary]] integers of any number of bits ([View Highlight](https://read.readwise.io/read/01hs9pvssxds4666w0w7kn22k5))
- the [[logic circuit]] diagrams get very complicated ([View Highlight](https://read.readwise.io/read/01hs9pwehfvymq92g9hdkvhbv5))
- a higher level of abstraction ([View Highlight](https://read.readwise.io/read/01hs9pwn3008hv99mcfy47r2a5))
- change the orientation of the box to better reflect that humans usually add numbers in columns ([View Highlight](https://read.readwise.io/read/01hs9pxhbsgasz6rqxw2n570gn))
- A sequence of 1-bit full adders that is used to add multi-bit [[binary]] integers, as shown in Figure 1.32, is called a full adder. ([View Highlight](https://read.readwise.io/read/01hs9q3zet5jsvv5w4506svn2p))
- If there are only 4 bits available for the result, this final carry out value cannot be stored, and we potentially have a serious [[overflow]] error ([View Highlight](https://read.readwise.io/read/01hs9q6bjnnkb9xmppj75banj8))
#### 1.3.4 What is inside a logic gate?
- how they are actually constructed – what exactly is inside a logic gate? ([View Highlight](https://read.readwise.io/read/01hs9v323pphg1g7pbnybjyjh3))
- made up of a combination of more fundamental components that act as on/off switches ([View Highlight](https://read.readwise.io/read/01hs9v3ehzfmh8mt1dvph6n2ax))
- early computers ([View Highlight](https://read.readwise.io/read/01hs9v3tjk6jncfh9g19mgqmf8))
- generally based on various designs of [[vacuum tube]] ([View Highlight](https://read.readwise.io/read/01hs9v3xgj58h8k0511j67n5qj))
- In modern computers, they are based on [[transistors]] ([View Highlight](https://read.readwise.io/read/01hs9v46605m6tjeag86jaa319))
- layers of semiconducting material such as [[silicon]] ([View Highlight](https://read.readwise.io/read/01hs9v4avg8qrmw6v2khkz4x6r))
- when they are in a circuit they conduct electricity well in one direction but less well in the other direction. ([View Highlight](https://read.readwise.io/read/01hs9v6bgn5yqrkyf6r6880qke))
- chip is used to convert a fluctuating voltage into the specific high voltage and low voltage values that define the 0s and 1s in the [[computer]] circuitry. ([View Highlight](https://read.readwise.io/read/01hs9v94anx2fyvjeyhpws0a0g))
